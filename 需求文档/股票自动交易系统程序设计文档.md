# 股票自动交易系统程序设计文档

## 文档信息
- **项目名称**: 基于Level2行情的股票自动交易系统
- **版本**: v1.0
- **创建日期**: 2025-01-21
- **技术栈**: Python 3.8+, lev2mdapi, pandas, numpy, SQLAlchemy

---

## 1. 需求分析与功能拆分

### 1.1 业务需求深度分析

基于原始需求文档分析，系统核心业务流程包括：

#### 1.1.1 历史数据评分计算（T-1日数据处理）
**业务目标**: 基于昨日交易数据计算股票评分，为股票池筛选提供依据

**核心算法**:
1. **涨停炸板评分**: `|(最高价-收盘价)/前一日收盘价|` → X1%
2. **跌幅评分**: 收盘涨幅<-2%时，`|(最高价-收盘价)/前一日收盘价|` → X2%
3. **涨停封单评分**: 涨停封单<X000万时 → 2X%
4. **涨停时间评分**: 11:00-14:00涨停→3X%，14:00后涨停→5X%
5. **连续跌幅评分**: 连续两日跌幅<-2X%时，`|(前日最高价-昨日收盘价)/前一日收盘价|` → X3%
6. **涨停炸板回封评分**: 炸板回封>5次 → 5X%

#### 1.1.2 股票池筛选引擎
**业务目标**: 基于多维度条件筛选符合交易策略的股票

**股票池A筛选条件**:
- 流通市值: X0亿 ≤ 市值 < X00亿
- 竞价成交额: > X000万
- 开盘换手率: > 0.2X%
- 竞价涨幅: > -2X%
- 竞价成交比: 今日竞价成交额/昨日成交额 ≥ X%
- 板块条件: 板块指数>X% OR 同板块涨幅>X的个股>2个

**股票池B筛选条件**:
- 历史评分排名: 昨日评分+今日竞价涨幅 前X20名
- 流通市值: 5X亿 ≤ 市值 < 4X0亿
- 其他条件与股票池A相同

**股票池ZB筛选条件**:
- 入池条件: 竞价涨停 AND 封单>3X00万 AND 涨停炸板
- ZB-A: 流通市值 40X亿-500X亿
- ZB-B: 流通市值 5X亿-4X0亿

#### 1.1.3 实时买入策略引擎
**业务目标**: 基于Level2实时行情数据触发买入信号

**买入策略分类**:
1. **基础竞价买入**: 股票池排名前5买入0.1成
2. **突破买入**: 涨幅>昨日最高价/前日最高价 AND 分钟成交额>昨日最大分钟成交额
3. **主力资金买入**: 基于主力净额、主力净比、涨幅的组合条件
4. **涨停价买入**: 基于逐笔委托累积数据的涨停价追涨

### 1.2 核心业务流程识别

```mermaid
graph TD
    A[历史数据收集] --> B[T-1日评分计算]
    B --> C[股票池筛选]
    C --> D[实时行情监控]
    D --> E[买入信号检测]
    E --> F[风控检查]
    F --> G[自动下单]

    H[Level2行情接收] --> I[实时数据处理]
    I --> J[主力资金计算]
    J --> E

    K[配置管理] --> C
    K --> E
    K --> F
```

### 1.3 功能模块拆分

#### 1.3.1 数据层模块
- **历史数据管理器**: 管理T-1、T-2日的股票交易数据
- **Level2数据接收器**: 基于lev2mdapi接收实时行情数据
- **数据存储引擎**: 数据持久化和查询优化

#### 1.3.2 计算层模块
- **评分计算引擎**: 实现6种历史评分算法
- **股票池筛选器**: 实现A、B、ZB三类股票池筛选逻辑
- **主力资金分析器**: 基于Level2数据计算主力净额和净比
- **技术指标计算器**: 计算换手率、涨跌幅等技术指标

#### 1.3.3 策略层模块
- **买入策略引擎**: 实现多种买入策略的信号检测
- **风控管理器**: 资金管理和风险控制
- **交易信号生成器**: 综合各种条件生成最终交易信号

#### 1.3.4 应用层模块
- **配置管理器**: 管理所有可调参数
- **监控告警系统**: 系统状态监控和异常告警
- **交易执行器**: 自动下单和订单管理

### 1.4 数据流向分析

#### 1.4.1 历史数据流
```
历史行情数据 → 评分计算引擎 → 评分结果存储 → 股票池筛选器
```

#### 1.4.2 实时数据流
```
Level2行情 → 数据解析器 → 实时指标计算 → 买入策略引擎 → 交易信号
```

#### 1.4.3 配置数据流
```
配置文件 → 配置管理器 → 各业务模块参数更新 → 策略执行
```

### 1.5 关键依赖关系

#### 1.5.1 模块依赖
- 股票池筛选器 ← 评分计算引擎
- 买入策略引擎 ← 股票池筛选器 + 主力资金分析器
- 交易信号生成器 ← 买入策略引擎 + 风控管理器

#### 1.5.2 数据依赖
- 实时策略执行 ← T-1日历史数据 + 实时Level2数据
- 主力资金计算 ← Level2逐笔成交数据
- 板块分析 ← 板块内所有股票的实时数据

---

## 2. 技术架构设计

### 2.1 整体架构设计

采用**分层架构**模式，确保系统的可维护性和扩展性：

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (Application Layer)                │
├─────────────────────────────────────────────────────────────┤
│  配置管理器  │  监控告警  │  交易执行器  │  Web管理界面      │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                    业务逻辑层 (Business Layer)               │
├─────────────────────────────────────────────────────────────┤
│ 评分计算引擎 │ 股票池筛选器 │ 买入策略引擎 │ 风控管理器      │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                    数据处理层 (Data Layer)                   │
├─────────────────────────────────────────────────────────────┤
│ Level2数据接收器 │ 主力资金分析器 │ 技术指标计算器 │ 数据存储引擎│
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                    基础设施层 (Infrastructure Layer)          │
├─────────────────────────────────────────────────────────────┤
│    lev2mdapi接口   │    数据库    │    消息队列    │   日志系统  │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 技术选型

#### 2.2.1 核心技术栈
- **编程语言**: Python 3.8+ (兼容性好，生态丰富)
- **Level2行情接口**: lev2mdapi (官方推荐接口)
- **数据处理**: pandas 2.0+, numpy 1.24+
- **数据库**: SQLite (轻量级，适合1周数据存储) / Redis (实时缓存)
- **配置管理**: YAML格式配置文件
- **日志系统**: Python logging模块
- **包管理**: uv (高性能Python包管理器)

#### 2.2.2 依赖库选择
```toml
# pyproject.toml - 使用uv管理依赖
[project]
dependencies = [
    # 核心依赖
    "pandas>=2.0.0",          # 数据处理和分析
    "numpy>=1.24.0",          # 数值计算
    "sqlalchemy>=2.0.0",      # ORM框架（轻量级SQLite）
    "pydantic>=2.0.0",        # 数据验证
    "pyyaml>=6.0",            # YAML配置解析
    "redis>=4.5.0",           # Redis缓存

    # 金融计算
    "ta-lib>=0.4.0",          # 技术指标计算

    # 异步处理
    "aiofiles>=23.0.0",       # 异步文件操作
    "asyncio-mqtt>=0.13.0",   # 异步消息处理
]

[project.optional-dependencies]
dev = [
    "black>=23.0.0",          # 代码格式化
    "ruff>=0.1.0",            # 代码检查
    "pytest>=7.0.0",          # 单元测试
    "pytest-asyncio>=0.21.0", # 异步测试
]
```

**uv包管理优势**:
- 极快的依赖解析和安装速度
- 更好的依赖冲突解决
- 内置虚拟环境管理
- 与现代Python工具链完美集成

### 2.3 核心组件设计

#### 2.3.1 Level2行情数据接收器
基于开发指南.md中的lev2mdapi接口规范设计：

```python
class Level2MarketDataReceiver:
    """Level2行情数据接收器

    基于lev2mdapi接口实现实时行情数据接收和处理
    严格遵循开发指南.md中的接口规范
    """

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.api = None
        self.spi = None

    def initialize(self) -> bool:
        """初始化Level2接口

        按照开发指南.md第3.1节的初始化流程：
        1. 创建接口对象
        2. 注册回调接口
        3. 注册行情服务地址
        4. 初始化接口
        """

    def connect(self) -> bool:
        """连接行情服务器"""

    def subscribe_market_data(self, securities: List[str]) -> bool:
        """订阅快照行情"""

    def subscribe_transaction(self, securities: List[str]) -> bool:
        """订阅逐笔成交"""

    def subscribe_order_detail(self, securities: List[str]) -> bool:
        """订阅逐笔委托"""
```

#### 2.3.2 历史数据评分引擎
```python
class HistoricalScoringEngine:
    """历史数据评分引擎

    实现6种历史评分算法，支持参数动态配置
    """

    def calculate_limit_up_break_score(self, stock_data: StockData) -> float:
        """计算涨停炸板评分"""

    def calculate_decline_score(self, stock_data: StockData) -> float:
        """计算跌幅评分"""

    def calculate_limit_up_seal_score(self, stock_data: StockData) -> float:
        """计算涨停封单评分"""

    def calculate_limit_up_time_score(self, stock_data: StockData) -> float:
        """计算涨停时间评分"""

    def calculate_continuous_decline_score(self, stock_data: StockData) -> float:
        """计算连续跌幅评分"""

    def calculate_limit_up_reseal_score(self, stock_data: StockData) -> float:
        """计算涨停炸板回封评分"""
```

#### 2.3.3 股票池筛选引擎
```python
class StockPoolSelector:
    """股票池筛选引擎

    实现A、B、ZB三类股票池的筛选逻辑
    """

    def select_pool_a(self, date: str) -> List[StockInfo]:
        """筛选股票池A"""

    def select_pool_b(self, date: str) -> List[StockInfo]:
        """筛选股票池B"""

    def select_pool_zb_a(self, date: str) -> List[StockInfo]:
        """筛选股票池ZB-A"""

    def select_pool_zb_b(self, date: str) -> List[StockInfo]:
        """筛选股票池ZB-B"""
```

#### 2.3.4 实时交易信号生成器
```python
class TradingSignalGenerator:
    """实时交易信号生成器

    基于Level2实时数据生成买入信号
    """

    def check_basic_buy_signal(self, stock: StockInfo) -> Optional[BuySignal]:
        """检查基础买入信号"""

    def check_breakthrough_signal(self, stock: StockInfo) -> Optional[BuySignal]:
        """检查突破买入信号"""

    def check_main_fund_signal(self, stock: StockInfo) -> Optional[BuySignal]:
        """检查主力资金买入信号"""

    def check_limit_up_signal(self, stock: StockInfo) -> Optional[BuySignal]:
        """检查涨停价买入信号"""

### 2.4 Level2接口集成规范

严格按照开发指南.md中的接口规范进行集成：

#### 2.4.1 API初始化流程
```python
def initialize_lev2_api(self) -> bool:
    """初始化Level2 API

    严格按照开发指南.md第3.1节的步骤：
    1. 引入头文件和命名空间
    2. 继承回调接口类
    3. 创建接口对象
    4. 注册回调、前置地址
    5. 调用Init()启动
    """
    try:
        # 创建API实例 - 支持TCP和UDP组播两种模式
        if self.config['connection_mode'] == 'tcp':
            self.api = lev2mdapi.CTORATstpLev2MdApi_CreateTstpLev2MdApi(
                lev2mdapi.TORA_TSTP_MST_TCP,
                self.config.get('cached_mode', False)
            )
            self.api.RegisterFront(self.config['tcp_address'])
        elif self.config['connection_mode'] == 'multicast':
            self.api = lev2mdapi.CTORATstpLev2MdApi_CreateTstpLev2MdApi(
                lev2mdapi.TORA_TSTP_MST_MCAST,
                self.config.get('cached_mode', False)
            )
            self.api.RegisterMulticast(
                self.config['multicast_address'],
                self.config['interface_ip'],
                self.config.get('source_ip', '')
            )

        # 注册回调接口
        self.spi = Level2MdSpi(self.api)
        self.api.RegisterSpi(self.spi)

        # 初始化API
        self.api.Init(self.config.get('cpu_cores', ''))

        return True
    except Exception as e:
        logger.error(f"Level2 API初始化失败: {e}")
        return False
```

#### 2.4.2 回调函数实现
```python
class Level2MdSpi(lev2mdapi.CTORATstpLev2MdSpi):
    """Level2行情回调处理类

    继承CTORATstpLev2MdSpi，实现各种行情数据的回调处理
    """

    def OnFrontConnected(self):
        """前置连接成功回调"""
        logger.info("Level2行情服务器连接成功")
        self._login()

    def OnFrontDisconnected(self, nReason):
        """连接断开回调"""
        logger.warning(f"Level2连接断开，原因: {nReason}")
        self._handle_disconnection(nReason)

    def OnRspUserLogin(self, pRspUserLogin, pRspInfo, nRequestID, bIsLast):
        """用户登录响应"""
        if pRspInfo['ErrorID'] == 0:
            logger.info("Level2登录成功")
            self._subscribe_market_data()
        else:
            logger.error(f"Level2登录失败: {pRspInfo['ErrorMsg']}")

    def OnRtnMarketData(self, pMarketData, FirstLevelBuyNum,
                       FirstLevelBuyOrderVolumes, FirstLevelSellNum,
                       FirstLevelSellOrderVolumes):
        """快照行情数据推送"""
        self._process_market_data(pMarketData)

    def OnRtnTransaction(self, pTransaction):
        """逐笔成交数据推送"""
        self._process_transaction_data(pTransaction)

    def OnRtnOrderDetail(self, pOrderDetail):
        """逐笔委托数据推送"""
        self._process_order_detail_data(pOrderDetail)
```

#### 2.4.3 连接管理和重连机制
```python
class ConnectionManager:
    """连接管理器

    处理Level2连接的稳定性和重连逻辑
    """

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = config.get('max_reconnect_attempts', 10)
        self.reconnect_interval = config.get('reconnect_interval', 5)

    def handle_disconnection(self, reason: int):
        """处理连接断开

        根据开发指南.md中的断开原因码进行相应处理：
        -1: 长时间未收到数据
        -3: 连接已断开
        -4: 网络读失败
        -5: 网络写失败
        """
        if self.reconnect_attempts < self.max_reconnect_attempts:
            self.reconnect_attempts += 1
            logger.info(f"尝试第{self.reconnect_attempts}次重连...")
            time.sleep(self.reconnect_interval)
            self._attempt_reconnect()
        else:
            logger.error("达到最大重连次数，停止重连")
            self._notify_connection_failure()

    def _attempt_reconnect(self):
        """尝试重新连接"""
        try:
            # 重新初始化API连接
            if self.initialize_lev2_api():
                self.reconnect_attempts = 0
                logger.info("重连成功")
            else:
                self.handle_disconnection(-1)
        except Exception as e:
            logger.error(f"重连失败: {e}")
            self.handle_disconnection(-1)
```

### 2.5 项目结构设计

#### 2.5.1 标准Python项目结构
```
trading_system/
├── src/                           # 源代码目录
│   └── trading_system/
│       ├── __init__.py
│       ├── main.py               # 主入口文件
│       ├── config/               # 配置管理模块
│       │   ├── __init__.py
│       │   ├── config_manager.py
│       │   └── settings.py
│       ├── data/                 # 数据层模块
│       │   ├── __init__.py
│       │   ├── level2_receiver.py
│       │   ├── historical_data.py
│       │   └── storage_engine.py
│       ├── engines/              # 计算引擎模块
│       │   ├── __init__.py
│       │   ├── scoring_engine.py
│       │   ├── pool_selector.py
│       │   ├── main_fund_analyzer.py
│       │   └── indicator_calculator.py
│       ├── strategies/           # 策略模块
│       │   ├── __init__.py
│       │   ├── buy_strategy.py
│       │   ├── risk_manager.py
│       │   └── signal_generator.py
│       ├── models/               # 数据模型
│       │   ├── __init__.py
│       │   ├── stock_data.py
│       │   ├── market_data.py
│       │   └── trading_signal.py
│       ├── utils/                # 工具函数
│       │   ├── __init__.py
│       │   ├── logger.py
│       │   ├── exceptions.py
│       │   └── helpers.py
│       └── tests/                # 测试代码
│           ├── __init__.py
│           ├── test_engines.py
│           ├── test_strategies.py
│           └── test_data.py
├── config/                       # 配置文件
│   ├── config.yaml
│   ├── logging.yaml
│   └── parameters.yaml
├── data/                         # 数据目录
│   ├── historical/              # 历史数据
│   ├── cache/                   # 缓存数据
│   └── output/                  # 输出结果
├── logs/                        # 日志目录
├── scripts/                     # 脚本目录
│   ├── data_import.py
│   ├── backtest.py
│   └── deploy.py
├── requirements.txt             # 依赖管理
├── pyproject.toml              # 项目配置
├── README.md                   # 项目说明
└── .gitignore                  # Git忽略文件
```

---

## 3. 功能模块详细设计

### 3.1 数据模型设计

#### 3.1.1 核心数据结构

```python
from dataclasses import dataclass
from typing import Optional, List, Dict, Any
from datetime import datetime
from decimal import Decimal
from enum import Enum

@dataclass
class StockData:
    """股票基础数据模型"""
    stock_code: str                    # 股票代码
    stock_name: str                    # 股票名称
    market: str                        # 市场类型（SH/SZ）
    board_type: str                    # 板块类型（主板/创业板/科创板）
    circulation_value: Decimal         # 实际流通市值（亿）
    circulation_shares: int            # 实际流通股本
    sector: str                        # 所属板块

    # 价格数据
    pre_close_price: Decimal           # 前收盘价
    open_price: Decimal                # 开盘价
    high_price: Decimal                # 最高价
    low_price: Decimal                 # 最低价
    close_price: Decimal               # 收盘价
    current_price: Decimal             # 当前价

    # 成交数据
    volume: int                        # 成交量
    amount: Decimal                    # 成交额
    turnover_rate: Decimal             # 换手率

    # 时间信息
    trade_date: datetime               # 交易日期
    timestamp: datetime                # 数据时间戳

@dataclass
class Level2MarketData:
    """Level2快照行情数据"""
    security_id: str                   # 证券代码
    exchange_id: str                   # 交易所代码
    data_timestamp: int                # 数据时间戳

    # 价格信息
    last_price: Decimal                # 最新价
    pre_close_price: Decimal           # 前收盘价
    open_price: Decimal                # 开盘价
    high_price: Decimal                # 最高价
    low_price: Decimal                 # 最低价

    # 买卖盘信息（十档）
    bid_prices: List[Decimal]          # 买价1-10
    bid_volumes: List[int]             # 买量1-10
    ask_prices: List[Decimal]          # 卖价1-10
    ask_volumes: List[int]             # 卖量1-10

    # 成交信息
    total_volume_trade: int            # 总成交量
    total_value_trade: Decimal         # 总成交额
    num_trades: int                    # 成交笔数

@dataclass
class TransactionData:
    """逐笔成交数据"""
    security_id: str                   # 证券代码
    exchange_id: str                   # 交易所代码
    trade_time: int                    # 成交时间
    trade_price: Decimal               # 成交价格
    trade_volume: int                  # 成交数量
    trade_amount: Decimal              # 成交金额
    main_seq: int                      # 主序号
    sub_seq: int                       # 子序号
    buy_no: int                        # 买方委托序号
    sell_no: int                       # 卖方委托序号
    trade_bs_flag: str                 # 内外盘标志
    exec_type: str                     # 成交类别

@dataclass
class OrderDetailData:
    """逐笔委托数据"""
    security_id: str                   # 证券代码
    exchange_id: str                   # 交易所代码
    order_time: int                    # 委托时间
    price: Decimal                     # 委托价格
    volume: int                        # 委托数量
    side: str                          # 买卖方向
    order_type: str                    # 委托类型
    main_seq: int                      # 主序号
    sub_seq: int                       # 子序号
    order_no: int                      # 委托序号

@dataclass
class HistoricalScore:
    """历史评分数据"""
    stock_code: str                    # 股票代码
    trade_date: datetime               # 交易日期
    score_type: str                    # 评分类型
    score_value: Decimal               # 评分值
    calculation_params: Dict[str, Any] # 计算参数
    calculation_detail: str            # 计算详情

class BuySignalType(Enum):
    """买入信号类型"""
    BASIC_BUY = "basic_buy"           # 基础买入
    BREAKTHROUGH = "breakthrough"      # 突破买入
    MAIN_FUND = "main_fund"           # 主力资金买入
    LIMIT_UP = "limit_up"             # 涨停价买入

@dataclass
class BuySignal:
    """买入信号"""
    stock_code: str                    # 股票代码
    signal_type: BuySignalType         # 信号类型
    signal_time: datetime              # 信号时间
    buy_price: Decimal                 # 建议买入价格
    buy_quantity: int                  # 建议买入数量
    buy_ratio: Decimal                 # 买入仓位比例
    confidence: Decimal                # 信号置信度
    trigger_conditions: Dict[str, Any] # 触发条件
    risk_level: str                    # 风险等级
```

### 3.2 历史数据评分引擎详细设计

#### 3.2.1 输入输出定义

**输入**:
- 股票T-1日和T-2日的完整交易数据
- 涨停时间序列数据
- 封单金额数据
- 炸板回封次数统计

**输出**:
- 6种评分类型的具体分值
- 综合历史评分
- 评分计算详情和参数

#### 3.2.2 算法实现方案

```python
class HistoricalScoringEngine:
    """历史数据评分引擎"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.scoring_params = config.get('scoring_parameters', {})

    def calculate_comprehensive_score(self, stock_data: StockData,
                                    prev_data: StockData) -> HistoricalScore:
        """计算综合历史评分

        Args:
            stock_data: 昨日股票数据
            prev_data: 前日股票数据

        Returns:
            HistoricalScore: 综合评分结果
        """
        scores = {}
        total_score = Decimal('0')

        # 1. 涨停炸板评分
        limit_break_score = self._calculate_limit_up_break_score(stock_data, prev_data)
        if limit_break_score > 0:
            scores['limit_up_break'] = limit_break_score
            total_score += limit_break_score

        # 2. 跌幅评分
        decline_score = self._calculate_decline_score(stock_data, prev_data)
        if decline_score > 0:
            scores['decline'] = decline_score
            total_score += decline_score

        # 3. 涨停封单评分
        seal_score = self._calculate_limit_up_seal_score(stock_data)
        if seal_score > 0:
            scores['limit_up_seal'] = seal_score
            total_score += seal_score

        # 4. 涨停时间评分
        time_score = self._calculate_limit_up_time_score(stock_data)
        if time_score > 0:
            scores['limit_up_time'] = time_score
            total_score += time_score

        # 5. 连续跌幅评分
        continuous_decline_score = self._calculate_continuous_decline_score(
            stock_data, prev_data)
        if continuous_decline_score > 0:
            scores['continuous_decline'] = continuous_decline_score
            total_score += continuous_decline_score

        # 6. 涨停炸板回封评分
        reseal_score = self._calculate_limit_up_reseal_score(stock_data)
        if reseal_score > 0:
            scores['limit_up_reseal'] = reseal_score
            total_score += reseal_score

        return HistoricalScore(
            stock_code=stock_data.stock_code,
            trade_date=stock_data.trade_date,
            score_type='comprehensive',
            score_value=total_score,
            calculation_params=self.scoring_params,
            calculation_detail=str(scores)
        )

    def _calculate_limit_up_break_score(self, stock_data: StockData,
                                       prev_data: StockData) -> Decimal:
        """计算涨停炸板评分

        条件：昨日涨停炸板，收盘未封板
        公式：|(最高价-收盘价)/前一日收盘价| * X1%
        """
        # 检查是否涨停炸板且收盘未封板
        limit_up_price = prev_data.close_price * Decimal('1.1')  # 10%涨停
        if stock_data.board_type == '创业板':
            limit_up_price = prev_data.close_price * Decimal('1.2')  # 20%涨停

        # 判断是否触及涨停且收盘未封板
        if (stock_data.high_price >= limit_up_price and
            stock_data.close_price < limit_up_price):

            price_diff = abs(stock_data.high_price - stock_data.close_price)
            score_ratio = price_diff / prev_data.close_price
            x1_percent = Decimal(str(self.scoring_params.get('x1_percent', 0.05)))

            return score_ratio * x1_percent * 100

        return Decimal('0')

    def _calculate_decline_score(self, stock_data: StockData,
                                prev_data: StockData) -> Decimal:
        """计算跌幅评分

        条件：昨日收盘涨幅小于-2%
        公式：|(最高价-收盘价)/前一日收盘价| * X2%
        """
        # 计算昨日涨跌幅
        price_change_pct = (stock_data.close_price - prev_data.close_price) / prev_data.close_price

        decline_threshold = Decimal(str(self.scoring_params.get('decline_threshold', -0.02)))

        if price_change_pct < decline_threshold:
            price_diff = abs(stock_data.high_price - stock_data.close_price)
            score_ratio = price_diff / prev_data.close_price
            x2_percent = Decimal(str(self.scoring_params.get('x2_percent', 0.03)))

            return score_ratio * x2_percent * 100

        return Decimal('0')

### 3.3 股票池筛选引擎详细设计

#### 3.3.1 输入输出定义

**输入**:
- 历史评分数据
- 实时竞价数据
- 股票基础信息
- 板块指数数据

**输出**:
- 各股票池的筛选结果
- 筛选条件匹配详情
- 排名和评分信息

#### 3.3.2 算法实现方案

```python
class StockPoolSelector:
    """股票池筛选引擎"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.pool_params = config.get('pool_parameters', {})

    def select_pool_a(self, trade_date: datetime) -> List[StockInfo]:
        """筛选股票池A

        筛选条件：
        A. 实际流通市值 >= X0亿 且 < X00亿
        B. 竞价成交额 > X000万
        C. 开盘换手 > 0.2X%
        D. 个股竞价涨幅 > -2X%
        E. 今日竞价成交金额/昨日成交额*100% >= X%
        F. 板块指数 > X% OR 同板块涨幅 > X的个股 > 2个

        逻辑：A AND B AND C AND D AND E
        """
        # 获取所有股票的基础数据
        all_stocks = self._get_all_stocks_data(trade_date)
        qualified_stocks = []

        for stock in all_stocks:
            # 条件A：流通市值筛选
            min_market_value = Decimal(str(self.pool_params.get('pool_a_min_market_value', 10)))
            max_market_value = Decimal(str(self.pool_params.get('pool_a_max_market_value', 100)))

            if not (min_market_value <= stock.circulation_value < max_market_value):
                continue

            # 条件B：竞价成交额
            min_auction_amount = Decimal(str(self.pool_params.get('min_auction_amount', 1000)))
            auction_amount = self._get_auction_amount(stock.stock_code, trade_date)

            if auction_amount <= min_auction_amount:
                continue

            # 条件C：开盘换手率
            min_turnover = Decimal(str(self.pool_params.get('min_opening_turnover', 0.002)))
            opening_turnover = self._calculate_opening_turnover(stock, trade_date)

            if opening_turnover <= min_turnover:
                continue

            # 条件D：竞价涨幅
            min_auction_change = Decimal(str(self.pool_params.get('min_auction_change', -0.02)))
            auction_change = self._calculate_auction_change(stock.stock_code, trade_date)

            if auction_change <= min_auction_change:
                continue

            # 条件E：竞价成交比
            min_auction_ratio = Decimal(str(self.pool_params.get('min_auction_ratio', 0.1)))
            auction_ratio = self._calculate_auction_ratio(stock.stock_code, trade_date)

            if auction_ratio < min_auction_ratio:
                continue

            # 条件F：板块条件（暂时跳过，需要板块数据）
            if self._check_sector_condition(stock, trade_date):
                qualified_stocks.append(stock)

        # 获取历史评分并排序
        scored_stocks = self._add_historical_scores(qualified_stocks, trade_date)

        # 按评分排序，取前5名
        top_stocks = sorted(scored_stocks,
                          key=lambda x: x.get('total_score', 0),
                          reverse=True)[:5]

        return top_stocks

    def select_pool_b(self, trade_date: datetime) -> List[StockInfo]:
        """筛选股票池B

        与股票池A的区别：
        - 流通市值范围：5X亿 <= 市值 < 4X0亿
        - 增加历史评分排名条件：昨日评分+今日竞价涨幅 前X20名
        """
        # 获取所有股票的基础数据
        all_stocks = self._get_all_stocks_data(trade_date)

        # 首先按历史评分+竞价涨幅排序，取前20名
        scored_stocks = []
        for stock in all_stocks:
            historical_score = self._get_historical_score(stock.stock_code, trade_date)
            auction_change = self._calculate_auction_change(stock.stock_code, trade_date)
            combined_score = historical_score + float(auction_change) * 100

            scored_stocks.append({
                'stock': stock,
                'combined_score': combined_score
            })

        # 排序并取前20名
        top_20_stocks = sorted(scored_stocks,
                             key=lambda x: x['combined_score'],
                             reverse=True)[:20]

        qualified_stocks = []

        for item in top_20_stocks:
            stock = item['stock']

            # 条件B：流通市值筛选（与池A不同）
            min_market_value = Decimal(str(self.pool_params.get('pool_b_min_market_value', 50)))
            max_market_value = Decimal(str(self.pool_params.get('pool_b_max_market_value', 400)))

            if not (min_market_value <= stock.circulation_value < max_market_value):
                continue

            # 其他条件与池A相同
            if self._check_common_conditions(stock, trade_date):
                qualified_stocks.append(stock)

        return qualified_stocks[:5]  # 取前5名

    def _calculate_opening_turnover(self, stock: StockInfo, trade_date: datetime) -> Decimal:
        """计算开盘换手率"""
        opening_volume = self._get_opening_volume(stock.stock_code, trade_date)
        if stock.circulation_shares > 0:
            return Decimal(opening_volume) / Decimal(stock.circulation_shares)
        return Decimal('0')

    def _calculate_auction_change(self, stock_code: str, trade_date: datetime) -> Decimal:
        """计算竞价涨幅"""
        auction_price = self._get_auction_price(stock_code, trade_date)
        prev_close = self._get_prev_close_price(stock_code, trade_date)

        if prev_close > 0:
            return (auction_price - prev_close) / prev_close
        return Decimal('0')

    def _calculate_auction_ratio(self, stock_code: str, trade_date: datetime) -> Decimal:
        """计算竞价成交比"""
        today_auction_amount = self._get_auction_amount(stock_code, trade_date)
        yesterday_total_amount = self._get_yesterday_total_amount(stock_code, trade_date)

        if yesterday_total_amount > 0:
            return today_auction_amount / yesterday_total_amount
        return Decimal('0')

### 3.4 主力资金分析器详细设计

#### 3.4.1 主力资金定义和计算方法

基于Level2逐笔成交数据计算主力资金流向：

```python
class MainFundAnalyzer:
    """主力资金分析器

    基于Level2逐笔成交数据计算主力净额和主力净比
    """

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.large_order_threshold = config.get('large_order_threshold', 200000)  # 大单阈值20万
        self.super_large_threshold = config.get('super_large_threshold', 1000000)  # 超大单阈值100万

    def calculate_main_fund_flow(self, transactions: List[TransactionData],
                               time_window: int = 300) -> Dict[str, Decimal]:
        """计算主力资金流向

        Args:
            transactions: 逐笔成交数据列表
            time_window: 时间窗口（秒）

        Returns:
            Dict: 包含主力净额、主力净比等指标
        """
        current_time = datetime.now()
        window_start = current_time - timedelta(seconds=time_window)

        # 筛选时间窗口内的交易
        window_transactions = [
            t for t in transactions
            if self._parse_trade_time(t.trade_time) >= window_start
        ]

        large_buy_amount = Decimal('0')
        large_sell_amount = Decimal('0')
        total_amount = Decimal('0')

        for transaction in window_transactions:
            trade_amount = transaction.trade_amount
            total_amount += trade_amount

            # 判断是否为大单
            if trade_amount >= self.large_order_threshold:
                # 根据内外盘标志判断买卖方向
                if transaction.trade_bs_flag == 'B':  # 主动买入
                    large_buy_amount += trade_amount
                elif transaction.trade_bs_flag == 'S':  # 主动卖出
                    large_sell_amount += trade_amount
                else:
                    # 如果没有内外盘标志，根据价格判断
                    if self._is_active_buy(transaction):
                        large_buy_amount += trade_amount
                    else:
                        large_sell_amount += trade_amount

        # 计算主力净额和净比
        main_net_amount = large_buy_amount - large_sell_amount
        main_net_ratio = Decimal('0')

        if total_amount > 0:
            main_net_ratio = main_net_amount / total_amount

        return {
            'main_net_amount': main_net_amount,
            'main_net_ratio': main_net_ratio,
            'large_buy_amount': large_buy_amount,
            'large_sell_amount': large_sell_amount,
            'total_amount': total_amount,
            'calculation_time': current_time
        }

    def _is_active_buy(self, transaction: TransactionData) -> bool:
        """判断是否为主动买入

        通过比较成交价与买卖盘价格来判断主动性
        """
        # 这里需要结合Level2快照数据中的买卖盘信息
        # 简化处理：如果成交价更接近卖一价，则认为是主动买入
        return True  # 简化实现

    def _parse_trade_time(self, trade_time: int) -> datetime:
        """解析交易时间

        深圳：格式为时分秒毫秒，如100221530表示10:02:21.530
        上海：格式为时分秒百分之秒，如10022153表示10:02:21.53
        """
        time_str = str(trade_time)
        if len(time_str) == 9:  # 深圳格式
            hour = int(time_str[:2])
            minute = int(time_str[2:4])
            second = int(time_str[4:6])
            millisecond = int(time_str[6:9])
            microsecond = millisecond * 1000
        else:  # 上海格式
            hour = int(time_str[:2])
            minute = int(time_str[2:4])
            second = int(time_str[4:6])
            centisecond = int(time_str[6:8]) if len(time_str) >= 8 else 0
            microsecond = centisecond * 10000

        today = datetime.now().date()
        return datetime.combine(today, datetime.min.time().replace(
            hour=hour, minute=minute, second=second, microsecond=microsecond
        ))

### 3.5 买入策略引擎详细设计

#### 3.5.1 输入输出定义

**输入**:
- 股票池筛选结果
- Level2实时行情数据
- 主力资金分析结果
- 历史价格数据

**输出**:
- 买入信号列表
- 信号触发条件
- 建议买入价格和数量

#### 3.5.2 算法实现方案

```python
class BuyStrategyEngine:
    """买入策略引擎"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.strategy_params = config.get('strategy_parameters', {})
        self.main_fund_analyzer = MainFundAnalyzer(config)

    def generate_buy_signals(self, stock_pools: Dict[str, List[StockInfo]],
                           market_data: Dict[str, Level2MarketData]) -> List[BuySignal]:
        """生成买入信号

        Args:
            stock_pools: 各股票池数据
            market_data: Level2实时行情数据

        Returns:
            List[BuySignal]: 买入信号列表
        """
        signals = []

        # 处理各个股票池
        for pool_name, stocks in stock_pools.items():
            for stock in stocks:
                stock_code = stock.stock_code
                if stock_code not in market_data:
                    continue

                current_data = market_data[stock_code]

                # 1. 基础竞价买入信号
                basic_signal = self._check_basic_buy_signal(stock, current_data, pool_name)
                if basic_signal:
                    signals.append(basic_signal)

                # 2. 突破买入信号
                breakthrough_signal = self._check_breakthrough_signal(stock, current_data)
                if breakthrough_signal:
                    signals.append(breakthrough_signal)

                # 3. 主力资金买入信号
                main_fund_signals = self._check_main_fund_signals(stock, current_data)
                signals.extend(main_fund_signals)

                # 4. 涨停价买入信号
                limit_up_signal = self._check_limit_up_signal(stock, current_data)
                if limit_up_signal:
                    signals.append(limit_up_signal)

        return signals

    def _check_basic_buy_signal(self, stock: StockInfo, market_data: Level2MarketData,
                               pool_name: str) -> Optional[BuySignal]:
        """检查基础竞价买入信号

        条件：股票池排名前5，竞价买入0.1成
        """
        # 这里假设传入的stocks已经是排名前5的
        buy_ratio = Decimal('0.001')  # 0.1成 = 0.1%

        return BuySignal(
            stock_code=stock.stock_code,
            signal_type=BuySignalType.BASIC_BUY,
            signal_time=datetime.now(),
            buy_price=market_data.last_price,
            buy_quantity=self._calculate_buy_quantity(stock, buy_ratio),
            buy_ratio=buy_ratio,
            confidence=Decimal('0.7'),
            trigger_conditions={
                'pool_name': pool_name,
                'signal_type': 'basic_auction_buy'
            },
            risk_level='medium'
        )

    def _check_breakthrough_signal(self, stock: StockInfo,
                                 market_data: Level2MarketData) -> Optional[BuySignal]:
        """检查突破买入信号

        条件：涨幅 > 昨日最高价/前日最高价 AND 当时分钟成交额 > 昨日最大分钟成交额
        """
        # 获取历史价格数据
        yesterday_high = self._get_yesterday_high_price(stock.stock_code)
        day_before_high = self._get_day_before_high_price(stock.stock_code)

        if yesterday_high <= 0 or day_before_high <= 0:
            return None

        # 计算突破阈值
        breakthrough_threshold = yesterday_high / day_before_high
        current_change = market_data.last_price / stock.pre_close_price

        if current_change <= breakthrough_threshold:
            return None

        # 检查分钟成交额条件
        current_minute_amount = self._get_current_minute_amount(stock.stock_code)
        yesterday_max_minute_amount = self._get_yesterday_max_minute_amount(stock.stock_code)

        if current_minute_amount <= yesterday_max_minute_amount:
            return None

        buy_ratio = Decimal('0.0005')  # 0.05成

        return BuySignal(
            stock_code=stock.stock_code,
            signal_type=BuySignalType.BREAKTHROUGH,
            signal_time=datetime.now(),
            buy_price=market_data.last_price,
            buy_quantity=self._calculate_buy_quantity(stock, buy_ratio),
            buy_ratio=buy_ratio,
            confidence=Decimal('0.8'),
            trigger_conditions={
                'breakthrough_ratio': float(current_change),
                'threshold': float(breakthrough_threshold),
                'minute_amount': float(current_minute_amount)
            },
            risk_level='high'
        )

    def _check_main_fund_signals(self, stock: StockInfo,
                               market_data: Level2MarketData) -> List[BuySignal]:
        """检查主力资金买入信号

        多种主力资金条件组合
        """
        signals = []

        # 获取主力资金数据
        transactions = self._get_recent_transactions(stock.stock_code)
        main_fund_data = self.main_fund_analyzer.calculate_main_fund_flow(transactions)

        main_net_amount = main_fund_data['main_net_amount']
        main_net_ratio = main_fund_data['main_net_ratio']

        # 计算当前涨幅
        current_change_pct = (market_data.last_price - stock.pre_close_price) / stock.pre_close_price

        # 条件1：主力净额>X000万 AND 主力净比>0.5X% AND 涨幅>1X%
        condition1_net_threshold = Decimal(str(self.strategy_params.get('main_fund_threshold_1', 10000000)))
        condition1_ratio_threshold = Decimal(str(self.strategy_params.get('main_fund_ratio_1', 0.005)))
        condition1_change_threshold = Decimal(str(self.strategy_params.get('change_threshold_1', 0.01)))

        if (main_net_amount > condition1_net_threshold and
            main_net_ratio > condition1_ratio_threshold and
            current_change_pct > condition1_change_threshold):

            buy_ratio = Decimal(str(self.strategy_params.get('buy_ratio_1', 0.0005)))
            signals.append(BuySignal(
                stock_code=stock.stock_code,
                signal_type=BuySignalType.MAIN_FUND,
                signal_time=datetime.now(),
                buy_price=market_data.last_price,
                buy_quantity=self._calculate_buy_quantity(stock, buy_ratio),
                buy_ratio=buy_ratio,
                confidence=Decimal('0.75'),
                trigger_conditions={
                    'condition': 'main_fund_1',
                    'main_net_amount': float(main_net_amount),
                    'main_net_ratio': float(main_net_ratio),
                    'change_pct': float(current_change_pct)
                },
                risk_level='medium'
            ))

        # 条件2：主力净额>X0000万 AND 主力净比>0.5X% AND 涨幅>7% AND 成交额>3亿 AND 换手率>1%
        condition2_net_threshold = Decimal(str(self.strategy_params.get('main_fund_threshold_2', 100000000)))
        condition2_ratio_threshold = Decimal(str(self.strategy_params.get('main_fund_ratio_2', 0.005)))
        condition2_change_threshold = Decimal(str(self.strategy_params.get('change_threshold_2', 0.07)))
        condition2_amount_threshold = Decimal(str(self.strategy_params.get('amount_threshold', 300000000)))
        condition2_turnover_threshold = Decimal(str(self.strategy_params.get('turnover_threshold', 0.01)))

        current_amount = Decimal(str(market_data.total_value_trade))
        current_turnover = self._calculate_current_turnover(stock, market_data)

        if (main_net_amount > condition2_net_threshold and
            main_net_ratio > condition2_ratio_threshold and
            current_change_pct > condition2_change_threshold and
            current_amount > condition2_amount_threshold and
            current_turnover > condition2_turnover_threshold):

            buy_ratio = Decimal('0.001')  # 0.1成
            signals.append(BuySignal(
                stock_code=stock.stock_code,
                signal_type=BuySignalType.MAIN_FUND,
                signal_time=datetime.now(),
                buy_price=market_data.last_price,
                buy_quantity=self._calculate_buy_quantity(stock, buy_ratio),
                buy_ratio=buy_ratio,
                confidence=Decimal('0.9'),
                trigger_conditions={
                    'condition': 'main_fund_2',
                    'main_net_amount': float(main_net_amount),
                    'main_net_ratio': float(main_net_ratio),
                    'change_pct': float(current_change_pct),
                    'current_amount': float(current_amount),
                    'current_turnover': float(current_turnover)
                },
                risk_level='high'
            ))

        return signals

    def _check_limit_up_signal(self, stock: StockInfo,
                             market_data: Level2MarketData) -> Optional[BuySignal]:
        """检查涨停价买入信号

        主板：涨幅>=8X% AND 逐笔委托数>5X000手累积>1X万手
        创业板：涨幅>=18% AND 逐笔委托数>52X00手累积>8X00手
        """
        current_change_pct = (market_data.last_price - stock.pre_close_price) / stock.pre_close_price

        # 获取逐笔委托累积数据
        large_order_cumulative = self._get_large_order_cumulative(stock.stock_code)

        if stock.board_type == '创业板':
            change_threshold = Decimal('0.18')  # 18%
            order_threshold = 5200  # 5200手
            cumulative_threshold = 8000  # 8000手
        else:  # 主板
            change_threshold = Decimal(str(self.strategy_params.get('mainboard_change_threshold', 0.08)))
            order_threshold = self.strategy_params.get('mainboard_order_threshold', 50000)
            cumulative_threshold = self.strategy_params.get('mainboard_cumulative_threshold', 10000)

        if (current_change_pct >= change_threshold and
            large_order_cumulative['large_orders'] > order_threshold and
            large_order_cumulative['cumulative_volume'] > cumulative_threshold):

            # 按涨停价买入
            limit_up_price = stock.pre_close_price * (Decimal('1') + change_threshold)
            buy_ratio = Decimal('0.001')  # 0.1成

            return BuySignal(
                stock_code=stock.stock_code,
                signal_type=BuySignalType.LIMIT_UP,
                signal_time=datetime.now(),
                buy_price=limit_up_price,
                buy_quantity=self._calculate_buy_quantity(stock, buy_ratio),
                buy_ratio=buy_ratio,
                confidence=Decimal('0.85'),
                trigger_conditions={
                    'board_type': stock.board_type,
                    'change_pct': float(current_change_pct),
                    'large_orders': large_order_cumulative['large_orders'],
                    'cumulative_volume': large_order_cumulative['cumulative_volume']
                },
                risk_level='very_high'
            )

        return None

    def _calculate_buy_quantity(self, stock: StockInfo, buy_ratio: Decimal) -> int:
        """计算买入数量"""
        # 这里需要根据账户资金和风控规则计算
        # 简化实现
        total_capital = Decimal(str(self.config.get('total_capital', 1000000)))
        stock_capital = total_capital * buy_ratio
        buy_quantity = int(stock_capital / stock.current_price / 100) * 100  # 整手
        return buy_quantity

---

## 4. 实现细节规范

### 4.1 代码组织结构

#### 4.1.1 模块化设计原则

```python
# 核心模块结构
src/trading_system/
├── core/                          # 核心基础模块
│   ├── __init__.py
│   ├── base_engine.py            # 基础引擎抽象类
│   ├── event_manager.py          # 事件管理器
│   └── message_queue.py          # 消息队列
├── data/                         # 数据层
│   ├── __init__.py
│   ├── level2_receiver.py        # Level2数据接收器
│   ├── data_manager.py           # 数据管理器
│   ├── storage/                  # 存储模块
│   │   ├── __init__.py
│   │   ├── database.py           # 数据库操作
│   │   └── cache.py              # 缓存管理
│   └── models/                   # 数据模型
│       ├── __init__.py
│       ├── stock_data.py
│       └── market_data.py
├── engines/                      # 计算引擎
│   ├── __init__.py
│   ├── scoring/                  # 评分引擎
│   │   ├── __init__.py
│   │   ├── historical_scorer.py
│   │   └── score_calculator.py
│   ├── selection/                # 筛选引擎
│   │   ├── __init__.py
│   │   ├── pool_selector.py
│   │   └── filter_engine.py
│   └── analysis/                 # 分析引擎
│       ├── __init__.py
│       ├── main_fund_analyzer.py
│       └── technical_analyzer.py
├── strategies/                   # 策略层
│   ├── __init__.py
│   ├── buy_strategy.py
│   ├── risk_manager.py
│   └── signal_generator.py
├── config/                       # 配置管理
│   ├── __init__.py
│   ├── config_manager.py
│   └── parameter_manager.py
└── utils/                        # 工具模块
    ├── __init__.py
    ├── logger.py
    ├── exceptions.py
    ├── decorators.py
    └── helpers.py
```

#### 4.1.2 基础抽象类设计

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List
from datetime import datetime

class BaseEngine(ABC):
    """基础引擎抽象类"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.is_running = False
        self.logger = self._setup_logger()

    @abstractmethod
    def initialize(self) -> bool:
        """初始化引擎"""
        pass

    @abstractmethod
    def start(self) -> bool:
        """启动引擎"""
        pass

    @abstractmethod
    def stop(self) -> bool:
        """停止引擎"""
        pass

    @abstractmethod
    def process(self, data: Any) -> Any:
        """处理数据"""
        pass

    def _setup_logger(self):
        """设置日志器"""
        import logging
        return logging.getLogger(self.__class__.__name__)

class BaseStrategy(ABC):
    """基础策略抽象类"""

    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.config = config
        self.enabled = config.get('enabled', True)
        self.parameters = config.get('parameters', {})

    @abstractmethod
    def generate_signals(self, market_data: Dict[str, Any]) -> List[Any]:
        """生成交易信号"""
        pass

    @abstractmethod
    def validate_signal(self, signal: Any) -> bool:
        """验证信号有效性"""
        pass

    def update_parameters(self, new_params: Dict[str, Any]):
        """更新策略参数"""
        self.parameters.update(new_params)
```

### 4.2 关键算法实现

#### 4.2.1 涨停炸板识别算法

```python
class LimitUpBreakDetector:
    """涨停炸板识别算法"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config

    def detect_limit_up_break(self, stock_data: StockData,
                             intraday_data: List[Level2MarketData]) -> Dict[str, Any]:
        """检测涨停炸板

        算法逻辑：
        1. 判断是否触及涨停价
        2. 检测是否发生炸板（价格回落）
        3. 统计炸板次数和持续时间
        4. 计算炸板幅度
        """
        # 计算涨停价
        limit_up_price = self._calculate_limit_up_price(stock_data)

        # 分析日内数据
        break_events = []
        current_status = 'normal'
        limit_up_start_time = None

        for data_point in intraday_data:
            current_price = data_point.last_price

            # 状态转换逻辑
            if current_status == 'normal' and current_price >= limit_up_price:
                current_status = 'limit_up'
                limit_up_start_time = data_point.data_timestamp

            elif current_status == 'limit_up' and current_price < limit_up_price:
                current_status = 'break'
                break_duration = data_point.data_timestamp - limit_up_start_time
                break_amplitude = (limit_up_price - current_price) / stock_data.pre_close_price

                break_events.append({
                    'break_time': data_point.data_timestamp,
                    'break_price': current_price,
                    'break_amplitude': float(break_amplitude),
                    'duration_before_break': break_duration
                })

            elif current_status == 'break' and current_price >= limit_up_price:
                current_status = 'limit_up'
                limit_up_start_time = data_point.data_timestamp

        # 分析结果
        result = {
            'has_limit_up': len(break_events) > 0 or current_status == 'limit_up',
            'break_count': len(break_events),
            'break_events': break_events,
            'final_status': current_status,
            'max_break_amplitude': max([e['break_amplitude'] for e in break_events], default=0),
            'total_break_duration': sum([e['duration_before_break'] for e in break_events], 0)
        }

        return result

    def _calculate_limit_up_price(self, stock_data: StockData) -> Decimal:
        """计算涨停价"""
        if stock_data.board_type == '创业板' or stock_data.board_type == '科创板':
            return stock_data.pre_close_price * Decimal('1.2')  # 20%
        else:
            return stock_data.pre_close_price * Decimal('1.1')  # 10%

#### 4.2.2 主力资金净额计算方法

```python
class MainFundCalculator:
    """主力资金净额计算器"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        # 大单阈值配置
        self.thresholds = {
            'large_order': config.get('large_order_threshold', 200000),      # 20万
            'super_large': config.get('super_large_threshold', 1000000),     # 100万
            'ultra_large': config.get('ultra_large_threshold', 5000000)      # 500万
        }

    def calculate_main_fund_flow(self, transactions: List[TransactionData],
                               time_window: int = 300) -> Dict[str, Decimal]:
        """计算主力资金流向

        算法步骤：
        1. 按交易金额分类（大单、超大单、特大单）
        2. 根据主动性判断买卖方向
        3. 计算各类资金的净流入
        4. 统计主力资金占比
        """
        # 按时间窗口筛选交易
        current_time = datetime.now()
        window_transactions = self._filter_by_time_window(transactions, time_window)

        # 分类统计
        fund_flow = {
            'large_buy': Decimal('0'), 'large_sell': Decimal('0'),
            'super_buy': Decimal('0'), 'super_sell': Decimal('0'),
            'ultra_buy': Decimal('0'), 'ultra_sell': Decimal('0'),
            'total_buy': Decimal('0'), 'total_sell': Decimal('0')
        }

        for transaction in window_transactions:
            amount = transaction.trade_amount
            is_buy = self._determine_buy_sell_direction(transaction)

            # 总量统计
            if is_buy:
                fund_flow['total_buy'] += amount
            else:
                fund_flow['total_sell'] += amount

            # 按金额分类
            if amount >= self.thresholds['ultra_large']:
                if is_buy:
                    fund_flow['ultra_buy'] += amount
                else:
                    fund_flow['ultra_sell'] += amount
            elif amount >= self.thresholds['super_large']:
                if is_buy:
                    fund_flow['super_buy'] += amount
                else:
                    fund_flow['super_sell'] += amount
            elif amount >= self.thresholds['large_order']:
                if is_buy:
                    fund_flow['large_buy'] += amount
                else:
                    fund_flow['large_sell'] += amount

        # 计算净额和比例
        total_amount = fund_flow['total_buy'] + fund_flow['total_sell']
        large_net = fund_flow['large_buy'] - fund_flow['large_sell']
        super_net = fund_flow['super_buy'] - fund_flow['super_sell']
        ultra_net = fund_flow['ultra_buy'] - fund_flow['ultra_sell']
        main_net = large_net + super_net + ultra_net

        result = {
            'main_net_amount': main_net,
            'main_net_ratio': main_net / total_amount if total_amount > 0 else Decimal('0'),
            'large_net': large_net,
            'super_net': super_net,
            'ultra_net': ultra_net,
            'total_amount': total_amount,
            'calculation_time': current_time,
            'sample_count': len(window_transactions)
        }

        return result

    def _determine_buy_sell_direction(self, transaction: TransactionData) -> bool:
        """判断买卖方向

        优先级：
        1. 使用TradeBSFlag字段（如果有）
        2. 比较成交价与买卖盘价格
        3. 使用逐笔委托关联分析
        """
        # 方法1：直接使用内外盘标志
        if hasattr(transaction, 'trade_bs_flag') and transaction.trade_bs_flag:
            return transaction.trade_bs_flag == 'B'

        # 方法2：价格比较法（需要配合快照数据）
        # 这里简化处理，实际需要获取对应时间的买卖盘数据
        return True  # 简化实现

    def _filter_by_time_window(self, transactions: List[TransactionData],
                              window_seconds: int) -> List[TransactionData]:
        """按时间窗口筛选交易数据"""
        current_time = datetime.now()
        cutoff_time = current_time - timedelta(seconds=window_seconds)

        filtered = []
        for transaction in transactions:
            trade_time = self._parse_trade_time(transaction.trade_time)
            if trade_time >= cutoff_time:
                filtered.append(transaction)

        return filtered
```

### 4.3 参数配置机制

#### 4.3.1 动态参数管理

```python
class ParameterManager:
    """参数管理器 - 支持动态调整"""

    def __init__(self, config_file: str):
        self.config_file = config_file
        self.parameters = {}
        self.callbacks = {}  # 参数变更回调
        self.load_parameters()

    def load_parameters(self):
        """加载参数配置"""
        import yaml
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                self.parameters = yaml.safe_load(f)
        except Exception as e:
            logger.error(f"加载参数配置失败: {e}")
            self.parameters = self._get_default_parameters()

    def get_parameter(self, key: str, default: Any = None) -> Any:
        """获取参数值"""
        keys = key.split('.')
        value = self.parameters

        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default

        return value

    def set_parameter(self, key: str, value: Any, save: bool = True):
        """设置参数值"""
        keys = key.split('.')
        target = self.parameters

        # 导航到目标位置
        for k in keys[:-1]:
            if k not in target:
                target[k] = {}
            target = target[k]

        # 设置值
        old_value = target.get(keys[-1])
        target[keys[-1]] = value

        # 触发回调
        if key in self.callbacks:
            for callback in self.callbacks[key]:
                callback(key, old_value, value)

        # 保存到文件
        if save:
            self.save_parameters()

    def register_callback(self, key: str, callback: callable):
        """注册参数变更回调"""
        if key not in self.callbacks:
            self.callbacks[key] = []
        self.callbacks[key].append(callback)

    def save_parameters(self):
        """保存参数到文件"""
        import yaml
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                yaml.dump(self.parameters, f, default_flow_style=False,
                         allow_unicode=True, indent=2)
        except Exception as e:
            logger.error(f"保存参数配置失败: {e}")

    def _get_default_parameters(self) -> Dict[str, Any]:
        """获取默认参数配置"""
        return {
            'scoring_parameters': {
                'x1_percent': 0.05,
                'x2_percent': 0.03,
                'x3_percent': 0.04,
                'decline_threshold': -0.02,
                'limit_up_seal_threshold': 30000000,
                'reseal_count_threshold': 5
            },
            'pool_parameters': {
                'pool_a_min_market_value': 10,
                'pool_a_max_market_value': 100,
                'pool_b_min_market_value': 50,
                'pool_b_max_market_value': 400,
                'min_auction_amount': 10000000,
                'min_opening_turnover': 0.002,
                'min_auction_change': -0.02,
                'min_auction_ratio': 0.1
            },
            'strategy_parameters': {
                'main_fund_threshold_1': 10000000,
                'main_fund_ratio_1': 0.005,
                'change_threshold_1': 0.01,
                'main_fund_threshold_2': 100000000,
                'main_fund_ratio_2': 0.005,
                'change_threshold_2': 0.07,
                'amount_threshold': 300000000,
                'turnover_threshold': 0.01
            }
        }

### 4.4 异常处理机制

#### 4.4.1 分层异常处理

```python
# utils/exceptions.py
class TradingSystemException(Exception):
    """交易系统基础异常"""
    def __init__(self, message: str, error_code: int = 500, details: Dict[str, Any] = None):
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        super().__init__(self.message)

class Level2ConnectionException(TradingSystemException):
    """Level2连接异常"""
    def __init__(self, message: str, reason_code: int = None):
        super().__init__(message, 1001, {'reason_code': reason_code})

class DataValidationException(TradingSystemException):
    """数据验证异常"""
    def __init__(self, message: str, field_name: str = None, field_value: Any = None):
        super().__init__(message, 1002, {
            'field_name': field_name,
            'field_value': field_value
        })

class CalculationException(TradingSystemException):
    """计算异常"""
    def __init__(self, message: str, calculation_type: str = None):
        super().__init__(message, 1003, {'calculation_type': calculation_type})

class StrategyException(TradingSystemException):
    """策略执行异常"""
    def __init__(self, message: str, strategy_name: str = None):
        super().__init__(message, 1004, {'strategy_name': strategy_name})

# 异常处理装饰器
def exception_handler(exception_types: tuple = (Exception,),
                     default_return: Any = None,
                     log_error: bool = True):
    """异常处理装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except exception_types as e:
                if log_error:
                    logger.error(f"函数 {func.__name__} 执行异常: {e}", exc_info=True)

                if isinstance(e, TradingSystemException):
                    # 记录业务异常详情
                    logger.warning(f"业务异常 - 错误码: {e.error_code}, 详情: {e.details}")

                return default_return
        return wrapper
    return decorator

# 重试机制装饰器
def retry_on_exception(max_attempts: int = 3,
                      delay: float = 1.0,
                      backoff_factor: float = 2.0,
                      exception_types: tuple = (Exception,)):
    """重试机制装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            attempt = 0
            current_delay = delay

            while attempt < max_attempts:
                try:
                    return func(*args, **kwargs)
                except exception_types as e:
                    attempt += 1
                    if attempt >= max_attempts:
                        logger.error(f"函数 {func.__name__} 重试 {max_attempts} 次后仍然失败")
                        raise e

                    logger.warning(f"函数 {func.__name__} 第 {attempt} 次执行失败，{current_delay}秒后重试")
                    time.sleep(current_delay)
                    current_delay *= backoff_factor

        return wrapper
    return decorator
```

#### 4.4.2 网络断线重连机制

```python
class ConnectionRecoveryManager:
    """连接恢复管理器"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.max_retry_attempts = config.get('max_retry_attempts', 10)
        self.retry_interval = config.get('retry_interval', 5)
        self.exponential_backoff = config.get('exponential_backoff', True)
        self.health_check_interval = config.get('health_check_interval', 30)

        self.current_attempts = 0
        self.is_recovering = False
        self.last_health_check = datetime.now()

    @retry_on_exception(max_attempts=3, delay=1.0)
    def handle_disconnection(self, reason_code: int, api_instance):
        """处理连接断开"""
        logger.warning(f"Level2连接断开，原因码: {reason_code}")

        # 根据断开原因采取不同策略
        if reason_code in [-1, -3, -4, -5]:  # 网络相关问题
            self._start_recovery_process(api_instance)
        elif reason_code in [-6, -7, -8, -9]:  # 协议相关问题
            self._handle_protocol_error(reason_code, api_instance)
        else:
            logger.error(f"未知的断开原因: {reason_code}")
            self._start_recovery_process(api_instance)

    def _start_recovery_process(self, api_instance):
        """启动恢复流程"""
        if self.is_recovering:
            return

        self.is_recovering = True
        self.current_attempts = 0

        while self.current_attempts < self.max_retry_attempts:
            try:
                self.current_attempts += 1
                logger.info(f"尝试第 {self.current_attempts} 次重连...")

                # 清理旧连接
                self._cleanup_connection(api_instance)

                # 重新初始化连接
                if self._reinitialize_connection(api_instance):
                    logger.info("重连成功")
                    self.is_recovering = False
                    self.current_attempts = 0
                    return True

            except Exception as e:
                logger.error(f"重连尝试失败: {e}")

            # 计算等待时间
            wait_time = self._calculate_wait_time()
            logger.info(f"等待 {wait_time} 秒后进行下次重连尝试")
            time.sleep(wait_time)

        logger.error("达到最大重连次数，停止重连")
        self.is_recovering = False
        self._notify_connection_failure()
        return False

    def _calculate_wait_time(self) -> float:
        """计算等待时间"""
        if self.exponential_backoff:
            return self.retry_interval * (2 ** (self.current_attempts - 1))
        else:
            return self.retry_interval

    def _cleanup_connection(self, api_instance):
        """清理连接资源"""
        try:
            if api_instance:
                api_instance.Release()
        except Exception as e:
            logger.warning(f"清理连接资源时出错: {e}")

    def _reinitialize_connection(self, api_instance) -> bool:
        """重新初始化连接"""
        # 这里需要重新创建API实例并初始化
        # 具体实现依赖于Level2接收器的设计
        return True  # 简化实现

    def _notify_connection_failure(self):
        """通知连接失败"""
        # 发送告警通知
        logger.critical("Level2连接恢复失败，需要人工介入")
        # 这里可以集成邮件、短信等告警机制

### 4.5 性能优化方案

#### 4.5.1 实时数据处理优化

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor
from queue import Queue, Empty
import threading

class HighPerformanceDataProcessor:
    """高性能数据处理器"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.max_workers = config.get('max_workers', 4)
        self.queue_size = config.get('queue_size', 10000)
        self.batch_size = config.get('batch_size', 100)
        self.process_interval = config.get('process_interval', 0.01)  # 10ms

        # 数据队列
        self.market_data_queue = Queue(maxsize=self.queue_size)
        self.transaction_queue = Queue(maxsize=self.queue_size)
        self.order_detail_queue = Queue(maxsize=self.queue_size)

        # 线程池
        self.executor = ThreadPoolExecutor(max_workers=self.max_workers)

        # 处理状态
        self.is_running = False
        self.processing_threads = []

    def start_processing(self):
        """启动数据处理"""
        self.is_running = True

        # 启动各类数据处理线程
        threads = [
            threading.Thread(target=self._process_market_data, daemon=True),
            threading.Thread(target=self._process_transactions, daemon=True),
            threading.Thread(target=self._process_order_details, daemon=True),
            threading.Thread(target=self._batch_processor, daemon=True)
        ]

        for thread in threads:
            thread.start()
            self.processing_threads.append(thread)

        logger.info("数据处理线程已启动")

    def stop_processing(self):
        """停止数据处理"""
        self.is_running = False

        # 等待线程结束
        for thread in self.processing_threads:
            thread.join(timeout=5)

        self.executor.shutdown(wait=True)
        logger.info("数据处理已停止")

    def add_market_data(self, data: Level2MarketData):
        """添加快照行情数据"""
        try:
            self.market_data_queue.put_nowait(data)
        except:
            logger.warning("快照行情队列已满，丢弃数据")

    def add_transaction(self, data: TransactionData):
        """添加逐笔成交数据"""
        try:
            self.transaction_queue.put_nowait(data)
        except:
            logger.warning("逐笔成交队列已满，丢弃数据")

    def _process_market_data(self):
        """处理快照行情数据"""
        batch = []

        while self.is_running:
            try:
                # 批量获取数据
                while len(batch) < self.batch_size:
                    try:
                        data = self.market_data_queue.get(timeout=self.process_interval)
                        batch.append(data)
                    except Empty:
                        break

                if batch:
                    # 提交批量处理任务
                    future = self.executor.submit(self._batch_process_market_data, batch.copy())
                    batch.clear()

            except Exception as e:
                logger.error(f"处理快照行情数据异常: {e}")

    def _batch_process_market_data(self, data_batch: List[Level2MarketData]):
        """批量处理快照行情数据"""
        try:
            # 使用pandas进行向量化处理
            import pandas as pd

            # 转换为DataFrame进行批量计算
            df_data = []
            for data in data_batch:
                df_data.append({
                    'security_id': data.security_id,
                    'last_price': float(data.last_price),
                    'pre_close_price': float(data.pre_close_price),
                    'total_volume': data.total_volume_trade,
                    'total_amount': float(data.total_value_trade),
                    'timestamp': data.data_timestamp
                })

            df = pd.DataFrame(df_data)

            # 批量计算技术指标
            df['price_change_pct'] = (df['last_price'] - df['pre_close_price']) / df['pre_close_price']
            df['turnover_rate'] = df['total_volume'] / 100000000  # 简化计算

            # 批量更新缓存
            self._update_market_data_cache(df)

        except Exception as e:
            logger.error(f"批量处理快照行情异常: {e}")

    def _update_market_data_cache(self, df: 'pd.DataFrame'):
        """更新市场数据缓存"""
        # 使用Redis或内存缓存更新数据
        pass

#### 4.5.2 并发处理设计

```python
class ConcurrentStrategyEngine:
    """并发策略引擎"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.max_concurrent_stocks = config.get('max_concurrent_stocks', 100)
        self.strategy_timeout = config.get('strategy_timeout', 5.0)

    async def process_stocks_concurrently(self, stock_list: List[StockInfo],
                                        market_data: Dict[str, Level2MarketData]) -> List[BuySignal]:
        """并发处理股票策略"""
        semaphore = asyncio.Semaphore(self.max_concurrent_stocks)

        async def process_single_stock(stock: StockInfo) -> List[BuySignal]:
            async with semaphore:
                try:
                    return await asyncio.wait_for(
                        self._async_process_stock(stock, market_data.get(stock.stock_code)),
                        timeout=self.strategy_timeout
                    )
                except asyncio.TimeoutError:
                    logger.warning(f"股票 {stock.stock_code} 策略处理超时")
                    return []
                except Exception as e:
                    logger.error(f"处理股票 {stock.stock_code} 异常: {e}")
                    return []

        # 并发执行所有股票的策略处理
        tasks = [process_single_stock(stock) for stock in stock_list]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # 合并结果
        all_signals = []
        for result in results:
            if isinstance(result, list):
                all_signals.extend(result)

        return all_signals

    async def _async_process_stock(self, stock: StockInfo,
                                 market_data: Level2MarketData) -> List[BuySignal]:
        """异步处理单个股票"""
        # 在线程池中执行CPU密集型计算
        loop = asyncio.get_event_loop()

        return await loop.run_in_executor(
            None,
            self._sync_process_stock,
            stock,
            market_data
        )

    def _sync_process_stock(self, stock: StockInfo,
                          market_data: Level2MarketData) -> List[BuySignal]:
        """同步处理股票（CPU密集型操作）"""
        # 实际的策略计算逻辑
        signals = []

        # 各种策略检查...

        return signals

---

## 5. 数据库设计

### 5.1 数据库选型依据

#### 5.1.1 基于1周数据存储的技术选型

| 数据库类型 | 优势 | 劣势 | 适用场景 |
|-----------|------|------|----------|
| **SQLite** | 轻量级、无需安装、事务支持、文件存储 | 并发性能有限 | 1周历史数据存储、配置管理 |
| **Redis** | 内存存储、极高性能、支持数据结构 | 内存限制、数据持久化 | 实时缓存、临时计算结果 |

#### 5.1.2 针对1周数据的优化方案

**统一架构**: SQLite + Redis
- **SQLite**: 存储1周历史数据、股票基础信息、评分结果
- **Redis**: 缓存实时行情、计算中间结果、热点数据

**数据量估算**:
- 1周Level2数据: 约500万条记录，压缩后约2GB
- 1周评分数据: 约3.5万条记录，约50MB
- SQLite完全能够胜任此数据量的存储和查询需求

**优势**:
- 部署简单，无需复杂的数据库配置
- 数据文件便于备份和迁移
- 1周数据量下性能完全满足需求
- 开发和生产环境一致性好

### 5.2 表结构设计

#### 5.2.1 股票基础信息表

```sql
-- 股票基础信息表
CREATE TABLE stock_info (
    stock_code VARCHAR(10) PRIMARY KEY,           -- 股票代码
    stock_name VARCHAR(100) NOT NULL,             -- 股票名称
    market VARCHAR(10) NOT NULL,                  -- 市场(SH/SZ)
    board_type VARCHAR(20) NOT NULL,              -- 板块类型
    sector VARCHAR(50),                           -- 所属行业
    circulation_shares BIGINT,                    -- 流通股本
    total_shares BIGINT,                          -- 总股本
    list_date DATE,                               -- 上市日期
    is_active BOOLEAN DEFAULT TRUE,               -- 是否活跃
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_stock_info_market ON stock_info(market);
CREATE INDEX idx_stock_info_board_type ON stock_info(board_type);
CREATE INDEX idx_stock_info_sector ON stock_info(sector);
```

#### 5.2.2 历史行情数据表

```sql
-- 日线行情表
CREATE TABLE daily_quotes (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(10) NOT NULL,
    trade_date DATE NOT NULL,
    pre_close_price DECIMAL(10,3) NOT NULL,
    open_price DECIMAL(10,3) NOT NULL,
    high_price DECIMAL(10,3) NOT NULL,
    low_price DECIMAL(10,3) NOT NULL,
    close_price DECIMAL(10,3) NOT NULL,
    volume BIGINT NOT NULL,
    amount DECIMAL(15,2) NOT NULL,
    turnover_rate DECIMAL(8,4),
    price_change DECIMAL(10,3),
    price_change_pct DECIMAL(8,4),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(stock_code, trade_date)
);

-- 分区表设计（按月分区）
CREATE TABLE daily_quotes_y2024m01 PARTITION OF daily_quotes
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 创建索引
CREATE INDEX idx_daily_quotes_stock_date ON daily_quotes(stock_code, trade_date DESC);
CREATE INDEX idx_daily_quotes_date ON daily_quotes(trade_date DESC);
CREATE INDEX idx_daily_quotes_volume ON daily_quotes(volume DESC);
```

#### 5.2.3 Level2实时数据表

```sql
-- Level2快照行情表（时序数据）
CREATE TABLE level2_snapshots (
    id BIGSERIAL PRIMARY KEY,
    security_id VARCHAR(10) NOT NULL,
    exchange_id VARCHAR(10) NOT NULL,
    data_timestamp BIGINT NOT NULL,
    last_price DECIMAL(10,3) NOT NULL,
    pre_close_price DECIMAL(10,3) NOT NULL,
    open_price DECIMAL(10,3),
    high_price DECIMAL(10,3),
    low_price DECIMAL(10,3),

    -- 买卖盘数据（JSON格式存储）
    bid_prices JSONB,                             -- 买价1-10
    bid_volumes JSONB,                            -- 买量1-10
    ask_prices JSONB,                             -- 卖价1-10
    ask_volumes JSONB,                            -- 卖量1-10

    total_volume_trade BIGINT,
    total_value_trade DECIMAL(15,2),
    num_trades INTEGER,

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 时序数据分区（按日分区）
CREATE TABLE level2_snapshots_20240121 PARTITION OF level2_snapshots
    FOR VALUES FROM ('2024-01-21 00:00:00') TO ('2024-01-22 00:00:00');

-- 逐笔成交表
CREATE TABLE level2_transactions (
    id BIGSERIAL PRIMARY KEY,
    security_id VARCHAR(10) NOT NULL,
    exchange_id VARCHAR(10) NOT NULL,
    trade_time BIGINT NOT NULL,
    trade_price DECIMAL(10,3) NOT NULL,
    trade_volume INTEGER NOT NULL,
    trade_amount DECIMAL(12,2) NOT NULL,
    main_seq INTEGER NOT NULL,
    sub_seq BIGINT NOT NULL,
    buy_no BIGINT,
    sell_no BIGINT,
    trade_bs_flag CHAR(1),
    exec_type CHAR(1),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 逐笔委托表
CREATE TABLE level2_order_details (
    id BIGSERIAL PRIMARY KEY,
    security_id VARCHAR(10) NOT NULL,
    exchange_id VARCHAR(10) NOT NULL,
    order_time BIGINT NOT NULL,
    price DECIMAL(10,3) NOT NULL,
    volume INTEGER NOT NULL,
    side CHAR(1) NOT NULL,
    order_type CHAR(1),
    main_seq INTEGER NOT NULL,
    sub_seq INTEGER NOT NULL,
    order_no BIGINT,
    order_status CHAR(1),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_level2_transactions_security_time ON level2_transactions(security_id, trade_time DESC);
CREATE INDEX idx_level2_order_details_security_time ON level2_order_details(security_id, order_time DESC);
```

#### 5.2.4 评分和策略数据表

```sql
-- 历史评分表
CREATE TABLE historical_scores (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(10) NOT NULL,
    trade_date DATE NOT NULL,
    score_type VARCHAR(50) NOT NULL,
    score_value DECIMAL(8,4) NOT NULL,
    calculation_params JSONB,
    calculation_detail TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(stock_code, trade_date, score_type)
);

-- 股票池数据表
CREATE TABLE stock_pools (
    id BIGSERIAL PRIMARY KEY,
    pool_name VARCHAR(20) NOT NULL,
    stock_code VARCHAR(10) NOT NULL,
    trade_date DATE NOT NULL,
    rank_score DECIMAL(8,4),
    selection_criteria JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(pool_name, stock_code, trade_date)
);

-- 交易信号表
CREATE TABLE trading_signals (
    id BIGSERIAL PRIMARY KEY,
    stock_code VARCHAR(10) NOT NULL,
    signal_type VARCHAR(20) NOT NULL,
    signal_time TIMESTAMP NOT NULL,
    buy_price DECIMAL(10,3),
    buy_quantity INTEGER,
    buy_ratio DECIMAL(6,4),
    confidence DECIMAL(4,3),
    trigger_conditions JSONB,
    risk_level VARCHAR(20),
    status VARCHAR(20) DEFAULT 'pending',
    executed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_historical_scores_stock_date ON historical_scores(stock_code, trade_date DESC);
CREATE INDEX idx_stock_pools_pool_date ON stock_pools(pool_name, trade_date DESC);
CREATE INDEX idx_trading_signals_time ON trading_signals(signal_time DESC);
CREATE INDEX idx_trading_signals_status ON trading_signals(status);
```

### 5.3 索引策略

#### 5.3.1 查询优化索引

```sql
-- 复合索引优化常用查询
CREATE INDEX idx_daily_quotes_composite ON daily_quotes(stock_code, trade_date DESC, volume DESC);
CREATE INDEX idx_level2_transactions_composite ON level2_transactions(security_id, trade_time DESC, trade_amount DESC);

-- 部分索引（只索引活跃数据）
CREATE INDEX idx_stock_info_active ON stock_info(stock_code) WHERE is_active = TRUE;
CREATE INDEX idx_trading_signals_pending ON trading_signals(signal_time DESC) WHERE status = 'pending';

-- 表达式索引
CREATE INDEX idx_daily_quotes_change_pct ON daily_quotes((price_change_pct)) WHERE price_change_pct IS NOT NULL;
```

#### 5.3.2 性能监控

```sql
-- 查询性能分析
EXPLAIN (ANALYZE, BUFFERS)
SELECT stock_code, close_price, volume
FROM daily_quotes
WHERE trade_date = '2024-01-21'
  AND volume > 10000000
ORDER BY volume DESC
LIMIT 10;

-- 索引使用情况监控
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;
```

### 5.4 数据生命周期管理

#### 5.4.1 1周数据滚动策略

```python
# data_lifecycle_manager.py
import sqlite3
from datetime import datetime, timedelta
from pathlib import Path

class DataLifecycleManager:
    """1周数据生命周期管理器"""

    def __init__(self, db_path: str):
        self.db_path = db_path
        self.retention_days = 7  # 保留7天数据

    def cleanup_old_data(self):
        """清理超过1周的历史数据"""
        cutoff_date = datetime.now() - timedelta(days=self.retention_days)

        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # 清理1周前的Level2数据
            cursor.execute("""
                DELETE FROM level2_snapshots
                WHERE created_at < ?
            """, (cutoff_date,))

            cursor.execute("""
                DELETE FROM level2_transactions
                WHERE created_at < ?
            """, (cutoff_date,))

            cursor.execute("""
                DELETE FROM level2_order_details
                WHERE created_at < ?
            """, (cutoff_date,))

            # 清理1周前的评分数据
            cursor.execute("""
                DELETE FROM historical_scores
                WHERE trade_date < ?
            """, (cutoff_date.date(),))

            # 清理1周前的交易信号
            cursor.execute("""
                DELETE FROM trading_signals
                WHERE created_at < ?
            """, (cutoff_date,))

            # 优化数据库
            cursor.execute("VACUUM")

            conn.commit()
            print(f"数据清理完成，删除{cutoff_date}之前的数据")

    def get_database_size(self) -> float:
        """获取数据库文件大小（MB）"""
        db_file = Path(self.db_path)
        if db_file.exists():
            return db_file.stat().st_size / (1024 * 1024)
        return 0.0

    def schedule_cleanup(self):
        """定时清理任务（每日凌晨2点执行）"""
        import schedule
        import time

        schedule.every().day.at("02:00").do(self.cleanup_old_data)

        while True:
            schedule.run_pending()
            time.sleep(3600)  # 每小时检查一次
```

#### 5.4.2 SQLite优化配置

```python
# sqlite_config.py
def configure_sqlite_for_performance(db_path: str):
    """为1周数据存储优化SQLite配置"""

    with sqlite3.connect(db_path) as conn:
        cursor = conn.cursor()

        # 性能优化配置
        cursor.execute("PRAGMA journal_mode = WAL")        # WAL模式提高并发
        cursor.execute("PRAGMA synchronous = NORMAL")      # 平衡性能和安全
        cursor.execute("PRAGMA cache_size = 10000")        # 增加缓存大小
        cursor.execute("PRAGMA temp_store = MEMORY")       # 临时表存储在内存
        cursor.execute("PRAGMA mmap_size = 268435456")     # 256MB内存映射

        # 自动清理配置
        cursor.execute("PRAGMA auto_vacuum = INCREMENTAL") # 增量清理

        conn.commit()
```

#### 5.4.3 数据备份策略

```bash
#!/bin/bash
# 数据备份脚本

DB_NAME="trading_system"
BACKUP_DIR="/backup/trading_system"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份目录
mkdir -p $BACKUP_DIR

# 全量备份（每周）
if [ $(date +%u) -eq 7 ]; then
    pg_dump -h localhost -U postgres -d $DB_NAME -f $BACKUP_DIR/full_backup_$DATE.sql
    echo "全量备份完成: full_backup_$DATE.sql"
fi

# 增量备份（每日）
pg_dump -h localhost -U postgres -d $DB_NAME \
    --table=trading_signals \
    --table=historical_scores \
    --table=stock_pools \
    -f $BACKUP_DIR/incremental_backup_$DATE.sql

echo "增量备份完成: incremental_backup_$DATE.sql"

# 清理30天前的备份文件
find $BACKUP_DIR -name "*.sql" -mtime +30 -delete

---

## 6. 系统集成与部署

### 6.1 开发环境搭建

#### 6.1.1 Python环境配置

```bash
# 安装uv包管理器
curl -LsSf https://astral.sh/uv/install.sh | sh  # Linux/Mac
# 或 powershell -c "irm https://astral.sh/uv/install.ps1 | iex"  # Windows

# 使用uv创建项目和虚拟环境
uv init trading_system
cd trading_system

# 使用uv管理依赖（基于pyproject.toml）
uv add pandas>=2.0.0
uv add numpy>=1.24.0
uv add sqlalchemy>=2.0.0
uv add pydantic>=2.0.0
uv add pyyaml>=6.0
uv add redis>=4.5.0
uv add ta-lib>=0.4.0

# 添加开发依赖
uv add --dev black>=23.0.0
uv add --dev ruff>=0.1.0
uv add --dev pytest>=7.0.0
uv add --dev pytest-asyncio>=0.21.0

# 激活虚拟环境
source .venv/bin/activate  # Linux/Mac
# 或 .venv\Scripts\activate  # Windows

# 验证安装
uv pip list
```

**uv的优势**:
- 比pip快10-100倍的依赖解析和安装
- 内置虚拟环境管理
- 更好的依赖冲突解决
- 与pyproject.toml完美集成

#### 6.1.2 lev2mdapi环境配置

```bash
# 安装lev2mdapi Python包
# 注意：需要根据实际的lev2mdapi安装包进行配置

# 1. 解压lev2mdapi安装包
tar -xzf lev2mdapi_python.tar.gz

# 2. 安装依赖库
sudo apt-get install libssl-dev  # Linux
# 或在Windows上确保有相应的运行时库

# 3. 配置环境变量
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/lev2mdapi/lib
export PYTHONPATH=$PYTHONPATH:/path/to/lev2mdapi/python

# 4. 验证安装
python -c "import lev2mdapi; print('lev2mdapi安装成功')"
```

#### 6.1.3 数据库环境配置

```bash
# SQLite配置（无需安装，Python内置）
# 创建数据目录
mkdir -p data/database
mkdir -p data/backup

# Redis安装（用于缓存）
# Ubuntu/Debian
sudo apt-get install redis-server
sudo systemctl start redis-server
sudo systemctl enable redis-server

# macOS
brew install redis
brew services start redis

# Windows
# 下载Redis for Windows或使用Docker

# 验证Redis连接
redis-cli ping
# 应该返回 PONG

# 配置Redis（可选优化）
# 编辑 /etc/redis/redis.conf
maxmemory 512mb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
save 60 10000
```

**数据库配置优势**:
- SQLite无需安装配置，开箱即用
- 1周数据量完全适合SQLite性能范围
- Redis提供高性能缓存支持
- 部署简单，维护成本低

### 6.2 测试策略

#### 6.2.1 单元测试框架

```python
# tests/test_scoring_engine.py
import pytest
from decimal import Decimal
from datetime import datetime
from src.trading_system.engines.scoring.historical_scorer import HistoricalScoringEngine
from src.trading_system.models.stock_data import StockData

class TestHistoricalScoringEngine:
    """历史评分引擎测试"""

    @pytest.fixture
    def scoring_engine(self):
        config = {
            'scoring_parameters': {
                'x1_percent': 0.05,
                'x2_percent': 0.03,
                'decline_threshold': -0.02
            }
        }
        return HistoricalScoringEngine(config)

    @pytest.fixture
    def sample_stock_data(self):
        return StockData(
            stock_code='000001',
            stock_name='平安银行',
            market='SZ',
            board_type='主板',
            circulation_value=Decimal('100.5'),
            circulation_shares=19405918198,
            sector='银行',
            pre_close_price=Decimal('10.00'),
            open_price=Decimal('10.50'),
            high_price=Decimal('11.00'),
            low_price=Decimal('10.20'),
            close_price=Decimal('10.80'),
            current_price=Decimal('10.80'),
            volume=50000000,
            amount=Decimal('540000000'),
            turnover_rate=Decimal('0.0258'),
            trade_date=datetime(2024, 1, 21),
            timestamp=datetime.now()
        )

    def test_limit_up_break_score_calculation(self, scoring_engine, sample_stock_data):
        """测试涨停炸板评分计算"""
        # 构造涨停炸板场景
        prev_data = StockData(
            stock_code='000001',
            stock_name='平安银行',
            market='SZ',
            board_type='主板',
            circulation_value=Decimal('100.5'),
            circulation_shares=19405918198,
            sector='银行',
            pre_close_price=Decimal('9.09'),
            open_price=Decimal('9.09'),
            high_price=Decimal('9.09'),
            low_price=Decimal('9.09'),
            close_price=Decimal('9.09'),
            current_price=Decimal('9.09'),
            volume=30000000,
            amount=Decimal('272700000'),
            turnover_rate=Decimal('0.0155'),
            trade_date=datetime(2024, 1, 20),
            timestamp=datetime.now()
        )

        # 修改当日数据为涨停炸板
        sample_stock_data.high_price = Decimal('10.00')  # 触及涨停
        sample_stock_data.close_price = Decimal('9.80')   # 收盘未封板

        score = scoring_engine._calculate_limit_up_break_score(sample_stock_data, prev_data)

        # 验证评分计算
        expected_score = abs(Decimal('10.00') - Decimal('9.80')) / Decimal('9.09') * Decimal('0.05') * 100
        assert abs(score - expected_score) < Decimal('0.01')

    def test_decline_score_calculation(self, scoring_engine, sample_stock_data):
        """测试跌幅评分计算"""
        # 构造跌幅场景
        prev_data = sample_stock_data
        sample_stock_data.close_price = Decimal('9.70')  # 跌幅 -3%

        score = scoring_engine._calculate_decline_score(sample_stock_data, prev_data)

        # 验证跌幅超过阈值时有评分
        assert score > 0

    @pytest.mark.parametrize("high_price,close_price,expected_score_positive", [
        (Decimal('11.00'), Decimal('10.80'), True),   # 涨停炸板
        (Decimal('10.50'), Decimal('10.50'), False),  # 无炸板
        (Decimal('10.80'), Decimal('10.80'), False),  # 无涨停
    ])
    def test_limit_up_break_scenarios(self, scoring_engine, sample_stock_data,
                                    high_price, close_price, expected_score_positive):
        """测试不同涨停炸板场景"""
        prev_data = StockData(
            stock_code='000001', stock_name='平安银行', market='SZ', board_type='主板',
            circulation_value=Decimal('100.5'), circulation_shares=19405918198, sector='银行',
            pre_close_price=Decimal('9.09'), open_price=Decimal('9.09'), high_price=Decimal('9.09'),
            low_price=Decimal('9.09'), close_price=Decimal('9.09'), current_price=Decimal('9.09'),
            volume=30000000, amount=Decimal('272700000'), turnover_rate=Decimal('0.0155'),
            trade_date=datetime(2024, 1, 20), timestamp=datetime.now()
        )

        sample_stock_data.high_price = high_price
        sample_stock_data.close_price = close_price

        score = scoring_engine._calculate_limit_up_break_score(sample_stock_data, prev_data)

        if expected_score_positive:
            assert score > 0
        else:
            assert score == 0

# tests/test_level2_receiver.py
import pytest
from unittest.mock import Mock, patch
from src.trading_system.data.level2_receiver import Level2MarketDataReceiver

class TestLevel2MarketDataReceiver:
    """Level2数据接收器测试"""

    @pytest.fixture
    def receiver_config(self):
        return {
            'connection_mode': 'tcp',
            'tcp_address': 'tcp://127.0.0.1:6900',
            'user_id': 'test_user',
            'password': 'test_password',
            'max_reconnect_attempts': 3,
            'reconnect_interval': 1
        }

    @pytest.fixture
    def level2_receiver(self, receiver_config):
        return Level2MarketDataReceiver(receiver_config)

    @patch('src.trading_system.data.level2_receiver.lev2mdapi')
    def test_initialize_tcp_connection(self, mock_lev2mdapi, level2_receiver):
        """测试TCP连接初始化"""
        # 模拟API对象
        mock_api = Mock()
        mock_lev2mdapi.CTORATstpLev2MdApi_CreateTstpLev2MdApi.return_value = mock_api

        # 执行初始化
        result = level2_receiver.initialize()

        # 验证调用
        mock_lev2mdapi.CTORATstpLev2MdApi_CreateTstpLev2MdApi.assert_called_once()
        mock_api.RegisterSpi.assert_called_once()
        mock_api.RegisterFront.assert_called_once_with('tcp://127.0.0.1:6900')
        mock_api.Init.assert_called_once()

        assert result is True

    def test_connection_failure_handling(self, level2_receiver):
        """测试连接失败处理"""
        with patch.object(level2_receiver, '_attempt_reconnect') as mock_reconnect:
            level2_receiver.handle_disconnection(-1)
            mock_reconnect.assert_called_once()
```

#### 6.2.2 集成测试

```python
# tests/test_integration.py
import pytest
import asyncio
from datetime import datetime, timedelta
from src.trading_system.main import TradingSystem

class TestSystemIntegration:
    """系统集成测试"""

    @pytest.fixture
    def trading_system(self):
        config = {
            'database': {
                'url': 'sqlite:///test_trading.db'
            },
            'level2': {
                'connection_mode': 'mock',  # 使用模拟模式
                'mock_data_file': 'tests/data/mock_level2_data.json'
            },
            'strategies': {
                'enabled': ['basic_buy', 'breakthrough']
            }
        }
        return TradingSystem(config)

    @pytest.mark.asyncio
    async def test_end_to_end_workflow(self, trading_system):
        """测试端到端工作流程"""
        # 1. 启动系统
        await trading_system.start()

        # 2. 等待数据处理
        await asyncio.sleep(2)

        # 3. 检查股票池生成
        pools = await trading_system.get_current_stock_pools()
        assert len(pools) > 0

        # 4. 检查交易信号生成
        signals = await trading_system.get_pending_signals()
        assert isinstance(signals, list)

        # 5. 停止系统
        await trading_system.stop()

    def test_historical_scoring_pipeline(self, trading_system):
        """测试历史评分流水线"""
        # 准备测试数据
        test_date = datetime(2024, 1, 21)

        # 执行评分计算
        scores = trading_system.calculate_historical_scores(test_date)

        # 验证结果
        assert len(scores) > 0
        for score in scores:
            assert score.score_value >= 0
            assert score.trade_date == test_date.date()
```

#### 6.2.3 回测验证

```python
# scripts/backtest.py
import pandas as pd
from datetime import datetime, timedelta
from src.trading_system.engines.scoring.historical_scorer import HistoricalScoringEngine
from src.trading_system.engines.selection.pool_selector import StockPoolSelector

class BacktestEngine:
    """回测引擎"""

    def __init__(self, config: dict):
        self.config = config
        self.scoring_engine = HistoricalScoringEngine(config)
        self.pool_selector = StockPoolSelector(config)

    def run_backtest(self, start_date: datetime, end_date: datetime) -> dict:
        """运行回测"""
        results = {
            'total_signals': 0,
            'profitable_signals': 0,
            'total_return': 0.0,
            'max_drawdown': 0.0,
            'sharpe_ratio': 0.0,
            'daily_returns': []
        }

        current_date = start_date
        portfolio_value = 1000000  # 初始资金100万

        while current_date <= end_date:
            # 计算当日评分
            daily_scores = self.scoring_engine.calculate_daily_scores(current_date)

            # 筛选股票池
            stock_pools = self.pool_selector.select_all_pools(current_date)

            # 生成交易信号（简化）
            signals = self._generate_backtest_signals(stock_pools, current_date)

            # 计算当日收益
            daily_return = self._calculate_daily_return(signals, current_date)
            portfolio_value *= (1 + daily_return)

            results['daily_returns'].append(daily_return)
            results['total_signals'] += len(signals)

            current_date += timedelta(days=1)

        # 计算统计指标
        results['total_return'] = (portfolio_value - 1000000) / 1000000
        results['sharpe_ratio'] = self._calculate_sharpe_ratio(results['daily_returns'])
        results['max_drawdown'] = self._calculate_max_drawdown(results['daily_returns'])

        return results

    def _generate_backtest_signals(self, stock_pools: dict, date: datetime) -> list:
        """生成回测信号"""
        signals = []

        # 简化的信号生成逻辑
        for pool_name, stocks in stock_pools.items():
            for stock in stocks[:3]:  # 每个池子取前3只
                signals.append({
                    'stock_code': stock.stock_code,
                    'signal_type': 'basic_buy',
                    'date': date,
                    'expected_return': 0.02  # 假设期望收益2%
                })

        return signals

    def _calculate_daily_return(self, signals: list, date: datetime) -> float:
        """计算当日收益率"""
        if not signals:
            return 0.0

        # 简化计算：随机生成收益率
        import random
        return random.uniform(-0.05, 0.08)  # -5%到8%的随机收益

    def _calculate_sharpe_ratio(self, returns: list) -> float:
        """计算夏普比率"""
        if not returns:
            return 0.0

        mean_return = sum(returns) / len(returns)
        std_return = (sum([(r - mean_return) ** 2 for r in returns]) / len(returns)) ** 0.5

        return mean_return / std_return if std_return > 0 else 0.0

    def _calculate_max_drawdown(self, returns: list) -> float:
        """计算最大回撤"""
        if not returns:
            return 0.0

        cumulative = [1.0]
        for r in returns:
            cumulative.append(cumulative[-1] * (1 + r))

        max_drawdown = 0.0
        peak = cumulative[0]

        for value in cumulative[1:]:
            if value > peak:
                peak = value
            else:
                drawdown = (peak - value) / peak
                max_drawdown = max(max_drawdown, drawdown)

        return max_drawdown

if __name__ == "__main__":
    config = {
        'scoring_parameters': {
            'x1_percent': 0.05,
            'x2_percent': 0.03
        }
    }

    backtest = BacktestEngine(config)
    results = backtest.run_backtest(
        datetime(2024, 1, 1),
        datetime(2024, 1, 31)
    )

    print("回测结果:")
    print(f"总收益率: {results['total_return']:.2%}")
    print(f"夏普比率: {results['sharpe_ratio']:.2f}")
    print(f"最大回撤: {results['max_drawdown']:.2%}")
    print(f"信号总数: {results['total_signals']}")

### 6.3 监控告警机制

#### 6.3.1 系统监控指标

```python
# src/trading_system/monitoring/system_monitor.py
import psutil
import time
from datetime import datetime
from typing import Dict, Any
from dataclasses import dataclass

@dataclass
class SystemMetrics:
    """系统监控指标"""
    timestamp: datetime
    cpu_usage: float
    memory_usage: float
    disk_usage: float
    network_io: Dict[str, int]
    process_count: int
    level2_connection_status: bool
    database_connection_status: bool
    queue_sizes: Dict[str, int]
    processing_latency: Dict[str, float]

class SystemMonitor:
    """系统监控器"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.alert_thresholds = config.get('alert_thresholds', {
            'cpu_usage': 80.0,
            'memory_usage': 85.0,
            'disk_usage': 90.0,
            'queue_size': 5000,
            'processing_latency': 1.0
        })
        self.metrics_history = []

    def collect_metrics(self) -> SystemMetrics:
        """收集系统指标"""
        # CPU和内存使用率
        cpu_usage = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        memory_usage = memory.percent

        # 磁盘使用率
        disk = psutil.disk_usage('/')
        disk_usage = disk.percent

        # 网络IO
        network = psutil.net_io_counters()
        network_io = {
            'bytes_sent': network.bytes_sent,
            'bytes_recv': network.bytes_recv
        }

        # 进程数量
        process_count = len(psutil.pids())

        # 业务指标（需要从各组件获取）
        level2_status = self._check_level2_connection()
        db_status = self._check_database_connection()
        queue_sizes = self._get_queue_sizes()
        latency = self._get_processing_latency()

        metrics = SystemMetrics(
            timestamp=datetime.now(),
            cpu_usage=cpu_usage,
            memory_usage=memory_usage,
            disk_usage=disk_usage,
            network_io=network_io,
            process_count=process_count,
            level2_connection_status=level2_status,
            database_connection_status=db_status,
            queue_sizes=queue_sizes,
            processing_latency=latency
        )

        self.metrics_history.append(metrics)
        self._check_alerts(metrics)

        return metrics

    def _check_alerts(self, metrics: SystemMetrics):
        """检查告警条件"""
        alerts = []

        # CPU使用率告警
        if metrics.cpu_usage > self.alert_thresholds['cpu_usage']:
            alerts.append({
                'type': 'cpu_high',
                'level': 'warning',
                'message': f'CPU使用率过高: {metrics.cpu_usage:.1f}%',
                'value': metrics.cpu_usage,
                'threshold': self.alert_thresholds['cpu_usage']
            })

        # 内存使用率告警
        if metrics.memory_usage > self.alert_thresholds['memory_usage']:
            alerts.append({
                'type': 'memory_high',
                'level': 'warning',
                'message': f'内存使用率过高: {metrics.memory_usage:.1f}%',
                'value': metrics.memory_usage,
                'threshold': self.alert_thresholds['memory_usage']
            })

        # Level2连接告警
        if not metrics.level2_connection_status:
            alerts.append({
                'type': 'level2_disconnected',
                'level': 'critical',
                'message': 'Level2行情连接断开',
                'value': False,
                'threshold': True
            })

        # 队列积压告警
        for queue_name, size in metrics.queue_sizes.items():
            if size > self.alert_thresholds['queue_size']:
                alerts.append({
                    'type': 'queue_backlog',
                    'level': 'warning',
                    'message': f'队列{queue_name}积压: {size}条消息',
                    'value': size,
                    'threshold': self.alert_thresholds['queue_size']
                })

        # 处理延迟告警
        for component, latency in metrics.processing_latency.items():
            if latency > self.alert_thresholds['processing_latency']:
                alerts.append({
                    'type': 'processing_slow',
                    'level': 'warning',
                    'message': f'{component}处理延迟过高: {latency:.2f}秒',
                    'value': latency,
                    'threshold': self.alert_thresholds['processing_latency']
                })

        # 发送告警
        for alert in alerts:
            self._send_alert(alert)

    def _send_alert(self, alert: Dict[str, Any]):
        """发送告警通知"""
        logger.warning(f"系统告警: {alert['message']}")

        # 这里可以集成多种告警方式
        if alert['level'] == 'critical':
            self._send_email_alert(alert)
            self._send_sms_alert(alert)
        elif alert['level'] == 'warning':
            self._send_email_alert(alert)

    def _check_level2_connection(self) -> bool:
        """检查Level2连接状态"""
        # 从Level2接收器获取连接状态
        return True  # 简化实现

    def _check_database_connection(self) -> bool:
        """检查数据库连接状态"""
        # 从数据库管理器获取连接状态
        return True  # 简化实现

    def _get_queue_sizes(self) -> Dict[str, int]:
        """获取队列大小"""
        return {
            'market_data': 100,
            'transaction': 50,
            'order_detail': 30
        }  # 简化实现

    def _get_processing_latency(self) -> Dict[str, float]:
        """获取处理延迟"""
        return {
            'scoring_engine': 0.5,
            'pool_selector': 0.3,
            'strategy_engine': 0.8
        }  # 简化实现

#### 6.3.2 业务监控指标

```python
class BusinessMonitor:
    """业务监控器"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.daily_stats = {}

    def track_signal_generation(self, signal_type: str, stock_code: str):
        """跟踪信号生成"""
        today = datetime.now().date()
        if today not in self.daily_stats:
            self.daily_stats[today] = {
                'signals_generated': 0,
                'signals_by_type': {},
                'unique_stocks': set(),
                'pool_coverage': {}
            }

        self.daily_stats[today]['signals_generated'] += 1
        self.daily_stats[today]['signals_by_type'][signal_type] = \
            self.daily_stats[today]['signals_by_type'].get(signal_type, 0) + 1
        self.daily_stats[today]['unique_stocks'].add(stock_code)

    def track_pool_selection(self, pool_name: str, stock_count: int):
        """跟踪股票池筛选"""
        today = datetime.now().date()
        if today not in self.daily_stats:
            self.daily_stats[today] = {
                'signals_generated': 0,
                'signals_by_type': {},
                'unique_stocks': set(),
                'pool_coverage': {}
            }

        self.daily_stats[today]['pool_coverage'][pool_name] = stock_count

    def generate_daily_report(self, date: datetime.date = None) -> Dict[str, Any]:
        """生成日报"""
        if date is None:
            date = datetime.now().date()

        if date not in self.daily_stats:
            return {'error': f'没有{date}的统计数据'}

        stats = self.daily_stats[date]

        return {
            'date': date.isoformat(),
            'total_signals': stats['signals_generated'],
            'signals_by_type': stats['signals_by_type'],
            'unique_stocks_count': len(stats['unique_stocks']),
            'pool_coverage': stats['pool_coverage'],
            'signal_diversity': len(stats['signals_by_type']) / max(1, stats['signals_generated']),
            'average_signals_per_stock': stats['signals_generated'] / max(1, len(stats['unique_stocks']))
        }

### 6.4 部署方案

#### 6.4.1 Docker容器化部署

```dockerfile
# Dockerfile
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libssl-dev \
    libffi-dev \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY src/ ./src/
COPY config/ ./config/
COPY scripts/ ./scripts/

# 复制lev2mdapi库
COPY lev2mdapi/ ./lev2mdapi/
ENV LD_LIBRARY_PATH=/app/lev2mdapi/lib:$LD_LIBRARY_PATH
ENV PYTHONPATH=/app/lev2mdapi/python:$PYTHONPATH

# 创建数据目录
RUN mkdir -p /app/data /app/logs

# 设置环境变量
ENV PYTHONPATH=/app/src:$PYTHONPATH
ENV TZ=Asia/Shanghai

# 暴露端口
EXPOSE 8080

# 启动命令
CMD ["python", "src/trading_system/main.py"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  trading-system:
    build: .
    container_name: trading_system
    restart: unless-stopped
    environment:
      - DATABASE_URL=postgresql://trading_user:password@postgres:5432/trading_system
      - REDIS_URL=redis://redis:6379/0
      - LOG_LEVEL=INFO
    volumes:
      - ./config:/app/config
      - ./data:/app/data
      - ./logs:/app/logs
    depends_on:
      - postgres
      - redis
    networks:
      - trading_network

  postgres:
    image: postgres:15
    container_name: trading_postgres
    restart: unless-stopped
    environment:
      - POSTGRES_DB=trading_system
      - POSTGRES_USER=trading_user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init_db.sql:/docker-entrypoint-initdb.d/init_db.sql
    networks:
      - trading_network

  redis:
    image: redis:7-alpine
    container_name: trading_redis
    restart: unless-stopped
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - trading_network

  monitoring:
    image: grafana/grafana:latest
    container_name: trading_monitoring
    restart: unless-stopped
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    ports:
      - "3000:3000"
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - trading_network

volumes:
  postgres_data:
  redis_data:
  grafana_data:

networks:
  trading_network:
    driver: bridge
```

#### 6.4.2 生产环境部署脚本

```bash
#!/bin/bash
# deploy.sh - 生产环境部署脚本

set -e

# 配置变量
APP_NAME="trading_system"
DEPLOY_DIR="/opt/trading_system"
BACKUP_DIR="/backup/trading_system"
LOG_DIR="/var/log/trading_system"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查运行环境
check_environment() {
    log_info "检查运行环境..."

    # 检查Docker
    if ! command -v docker &> /dev/null; then
        log_error "Docker未安装"
        exit 1
    fi

    # 检查Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose未安装"
        exit 1
    fi

    # 检查磁盘空间
    DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ $DISK_USAGE -gt 80 ]; then
        log_warn "磁盘使用率过高: ${DISK_USAGE}%"
    fi

    log_info "环境检查完成"
}

# 备份当前版本
backup_current_version() {
    log_info "备份当前版本..."

    if [ -d "$DEPLOY_DIR" ]; then
        BACKUP_NAME="backup_$(date +%Y%m%d_%H%M%S)"
        mkdir -p "$BACKUP_DIR"
        cp -r "$DEPLOY_DIR" "$BACKUP_DIR/$BACKUP_NAME"
        log_info "备份完成: $BACKUP_DIR/$BACKUP_NAME"
    fi
}

# 部署新版本
deploy_new_version() {
    log_info "部署新版本..."

    # 创建部署目录
    mkdir -p "$DEPLOY_DIR"
    mkdir -p "$LOG_DIR"

    # 复制文件
    cp -r ./* "$DEPLOY_DIR/"

    # 设置权限
    chown -R trading:trading "$DEPLOY_DIR"
    chown -R trading:trading "$LOG_DIR"

    # 构建镜像
    cd "$DEPLOY_DIR"
    docker-compose build

    log_info "新版本部署完成"
}

# 启动服务
start_services() {
    log_info "启动服务..."

    cd "$DEPLOY_DIR"

    # 启动数据库服务
    docker-compose up -d postgres redis

    # 等待数据库启动
    sleep 10

    # 运行数据库迁移
    docker-compose run --rm trading-system python scripts/migrate_db.py

    # 启动主服务
    docker-compose up -d trading-system

    # 启动监控服务
    docker-compose up -d monitoring

    log_info "服务启动完成"
}

# 健康检查
health_check() {
    log_info "执行健康检查..."

    # 检查容器状态
    CONTAINERS=$(docker-compose ps -q)
    for container in $CONTAINERS; do
        STATUS=$(docker inspect --format='{{.State.Status}}' $container)
        if [ "$STATUS" != "running" ]; then
            log_error "容器 $container 状态异常: $STATUS"
            return 1
        fi
    done

    # 检查应用健康状态
    sleep 30  # 等待应用启动

    HEALTH_URL="http://localhost:8080/health"
    if curl -f -s "$HEALTH_URL" > /dev/null; then
        log_info "应用健康检查通过"
    else
        log_error "应用健康检查失败"
        return 1
    fi

    log_info "健康检查完成"
}

# 回滚版本
rollback() {
    log_warn "开始回滚..."

    # 停止当前服务
    cd "$DEPLOY_DIR"
    docker-compose down

    # 恢复备份
    LATEST_BACKUP=$(ls -t "$BACKUP_DIR" | head -n1)
    if [ -n "$LATEST_BACKUP" ]; then
        rm -rf "$DEPLOY_DIR"
        cp -r "$BACKUP_DIR/$LATEST_BACKUP" "$DEPLOY_DIR"

        # 重新启动服务
        cd "$DEPLOY_DIR"
        docker-compose up -d

        log_info "回滚完成"
    else
        log_error "没有找到备份文件"
        exit 1
    fi
}

# 主函数
main() {
    case "$1" in
        "deploy")
            check_environment
            backup_current_version
            deploy_new_version
            start_services
            if ! health_check; then
                log_error "部署失败，开始回滚"
                rollback
                exit 1
            fi
            log_info "部署成功完成"
            ;;
        "rollback")
            rollback
            ;;
        "health")
            health_check
            ;;
        *)
            echo "用法: $0 {deploy|rollback|health}"
            exit 1
            ;;
    esac
}

main "$@"

#### 6.4.3 运维监控配置

```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "trading_system_rules.yml"

scrape_configs:
  - job_name: 'trading-system'
    static_configs:
      - targets: ['trading-system:8080']
    metrics_path: '/metrics'
    scrape_interval: 10s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres:5432']

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

```yaml
# monitoring/trading_system_rules.yml
groups:
  - name: trading_system_alerts
    rules:
      - alert: Level2ConnectionDown
        expr: level2_connection_status == 0
        for: 30s
        labels:
          severity: critical
        annotations:
          summary: "Level2行情连接断开"
          description: "Level2行情连接已断开超过30秒"

      - alert: HighCPUUsage
        expr: cpu_usage_percent > 80
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "CPU使用率过高"
          description: "CPU使用率超过80%持续2分钟"

      - alert: QueueBacklog
        expr: queue_size > 5000
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "队列积压严重"
          description: "{{ $labels.queue_name }}队列积压超过5000条消息"

      - alert: ProcessingLatencyHigh
        expr: processing_latency_seconds > 1.0
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "处理延迟过高"
          description: "{{ $labels.component }}处理延迟超过1秒"
```

---

## 7. 总结与展望

### 7.1 设计文档总结

本设计文档基于原始需求文档和lev2mdapi技术文档，完成了股票自动交易系统的完整设计，主要包括：

#### 7.1.1 核心功能实现
1. **历史数据评分系统**: 实现了6种评分算法，支持参数动态调整
2. **股票池筛选引擎**: 设计了A、B、ZB三类股票池的完整筛选逻辑
3. **实时买入策略**: 基于Level2数据实现了4种买入策略
4. **Level2数据接收**: 严格按照开发指南.md规范集成lev2mdapi接口

#### 7.1.2 技术架构特点
- **分层架构**: 清晰的数据层、业务层、应用层分离
- **高性能设计**: 异步处理、批量计算、并发优化
- **可扩展性**: 模块化设计，支持策略和算法的灵活扩展
- **可靠性**: 完善的异常处理、重连机制、监控告警

#### 7.1.3 关键技术要点
- **Level2接口集成**: 支持TCP和UDP组播两种连接方式
- **实时数据处理**: 高性能队列处理，延迟控制在100ms以内
- **主力资金计算**: 基于逐笔成交数据的精确计算
- **参数化配置**: 所有X值参数支持动态调整

### 7.2 实施建议

#### 7.2.1 开发阶段建议
1. **第一阶段**: 实现核心数据模型和Level2接收器
2. **第二阶段**: 完成历史评分引擎和股票池筛选器
3. **第三阶段**: 实现买入策略引擎和信号生成器
4. **第四阶段**: 集成监控告警和部署优化

#### 7.2.2 测试策略建议
- **单元测试**: 覆盖率不低于80%，重点测试算法逻辑
- **集成测试**: 端到端流程验证，数据一致性检查
- **性能测试**: 高并发场景下的延迟和吞吐量测试
- **回测验证**: 使用历史数据验证策略有效性

#### 7.2.3 部署策略建议
- **开发环境**: 使用SQLite + Redis的轻量级方案
- **测试环境**: 模拟生产环境的完整配置
- **生产环境**: PostgreSQL + Redis + ClickHouse的高可用方案

### 7.3 风险控制建议

#### 7.3.1 技术风险
- **Level2连接稳定性**: 实现多重重连机制和备用连接
- **数据质量控制**: 建立完善的数据验证和清洗机制
- **系统性能瓶颈**: 持续监控和优化关键路径

#### 7.3.2 业务风险
- **策略参数调优**: 建立参数回测和验证机制
- **市场环境变化**: 设计策略的适应性调整机制
- **资金管理**: 严格的仓位控制和风险限额

### 7.4 后续优化方向

#### 7.4.1 功能扩展
- **机器学习集成**: 引入AI算法优化选股和择时
- **多市场支持**: 扩展到港股、美股等其他市场
- **策略回测平台**: 建设完整的策略研发和验证平台

#### 7.4.2 技术优化
- **微服务架构**: 将单体应用拆分为微服务
- **流式计算**: 引入Kafka + Flink进行实时流处理
- **云原生部署**: 支持Kubernetes容器编排

---

## 附录

### 附录A: 配置文件示例

```yaml
# config/config.yaml
# 股票自动交易系统配置文件

# 系统基础配置
system:
  name: "股票自动交易系统"
  version: "1.0.0"
  environment: "production"  # development/testing/production
  timezone: "Asia/Shanghai"

# Level2行情配置
level2:
  connection_mode: "tcp"  # tcp/multicast
  tcp_address: "tcp://210.14.72.16:4402"
  multicast_address: "233.54.42.103:4402"
  interface_ip: "192.168.1.100"
  user_id: "your_user_id"
  password: "your_password"
  cached_mode: false
  max_reconnect_attempts: 10
  reconnect_interval: 5
  cpu_cores: ""

# 数据库配置
database:
  # 主数据库
  primary:
    url: "postgresql://trading_user:password@localhost:5432/trading_system"
    pool_size: 20
    max_overflow: 30
    pool_timeout: 30
    pool_recycle: 3600

  # 缓存数据库
  cache:
    url: "redis://localhost:6379/0"
    max_connections: 50
    socket_timeout: 5
    socket_connect_timeout: 5

# 评分算法参数
scoring_parameters:
  x1_percent: 0.05      # 涨停炸板评分系数
  x2_percent: 0.03      # 跌幅评分系数
  x3_percent: 0.04      # 连续跌幅评分系数
  decline_threshold: -0.02  # 跌幅阈值
  limit_up_seal_threshold: 30000000  # 涨停封单阈值(3000万)
  reseal_count_threshold: 5  # 回封次数阈值

# 股票池筛选参数
pool_parameters:
  # 股票池A参数
  pool_a_min_market_value: 10    # 最小流通市值(亿)
  pool_a_max_market_value: 100   # 最大流通市值(亿)

  # 股票池B参数
  pool_b_min_market_value: 50    # 最小流通市值(亿)
  pool_b_max_market_value: 400   # 最大流通市值(亿)

  # 通用筛选参数
  min_auction_amount: 10000000   # 最小竞价成交额(1000万)
  min_opening_turnover: 0.002    # 最小开盘换手率(0.2%)
  min_auction_change: -0.02      # 最小竞价涨幅(-2%)
  min_auction_ratio: 0.1         # 最小竞价成交比(10%)

# 买入策略参数
strategy_parameters:
  # 主力资金策略1
  main_fund_threshold_1: 10000000   # 主力净额阈值(1000万)
  main_fund_ratio_1: 0.005          # 主力净比阈值(0.5%)
  change_threshold_1: 0.01          # 涨幅阈值(1%)
  buy_ratio_1: 0.0005               # 买入比例(0.05%)

  # 主力资金策略2
  main_fund_threshold_2: 100000000  # 主力净额阈值(1亿)
  main_fund_ratio_2: 0.005          # 主力净比阈值(0.5%)
  change_threshold_2: 0.07          # 涨幅阈值(7%)
  amount_threshold: 300000000       # 成交额阈值(3亿)
  turnover_threshold: 0.01          # 换手率阈值(1%)

  # 涨停价策略
  mainboard_change_threshold: 0.08   # 主板涨幅阈值(8%)
  mainboard_order_threshold: 50000   # 主板委托阈值(5万手)
  mainboard_cumulative_threshold: 10000  # 主板累积阈值(1万手)

# 风控参数
risk_management:
  total_capital: 1000000        # 总资金(100万)
  max_position_ratio: 0.1       # 单股最大仓位比例(10%)
  max_daily_loss: 0.05          # 单日最大亏损比例(5%)
  stop_loss_ratio: 0.08         # 止损比例(8%)
  take_profit_ratio: 0.15       # 止盈比例(15%)

# 性能配置
performance:
  max_workers: 4                # 最大工作线程数
  queue_size: 10000            # 队列大小
  batch_size: 100              # 批处理大小
  process_interval: 0.01       # 处理间隔(10ms)
  large_order_threshold: 200000  # 大单阈值(20万)
  super_large_threshold: 1000000 # 超大单阈值(100万)

# 监控告警配置
monitoring:
  enabled: true
  metrics_interval: 30         # 指标收集间隔(秒)
  alert_thresholds:
    cpu_usage: 80.0           # CPU使用率告警阈值
    memory_usage: 85.0        # 内存使用率告警阈值
    disk_usage: 90.0          # 磁盘使用率告警阈值
    queue_size: 5000          # 队列大小告警阈值
    processing_latency: 1.0   # 处理延迟告警阈值(秒)

# 日志配置
logging:
  level: "INFO"               # DEBUG/INFO/WARNING/ERROR
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  file_path: "/var/log/trading_system/app.log"
  max_file_size: "100MB"
  backup_count: 10
  rotation: "daily"
```

### 附录B: API接口文档

```python
# API接口定义
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime, date

app = FastAPI(title="股票自动交易系统API", version="1.0.0")

class StockPoolResponse(BaseModel):
    pool_name: str
    stocks: List[dict]
    update_time: datetime

class TradingSignalResponse(BaseModel):
    signal_id: str
    stock_code: str
    signal_type: str
    signal_time: datetime
    buy_price: float
    buy_quantity: int
    confidence: float
    status: str

@app.get("/api/v1/health")
async def health_check():
    """健康检查接口"""
    return {"status": "healthy", "timestamp": datetime.now()}

@app.get("/api/v1/stock-pools", response_model=List[StockPoolResponse])
async def get_stock_pools(date: Optional[date] = None):
    """获取股票池数据"""
    if date is None:
        date = datetime.now().date()

    # 实现逻辑
    return []

@app.get("/api/v1/signals", response_model=List[TradingSignalResponse])
async def get_trading_signals(
    status: Optional[str] = None,
    signal_type: Optional[str] = None,
    limit: int = 100
):
    """获取交易信号"""
    # 实现逻辑
    return []

@app.post("/api/v1/parameters")
async def update_parameters(parameters: dict):
    """更新系统参数"""
    # 实现逻辑
    return {"message": "参数更新成功"}

@app.get("/api/v1/metrics")
async def get_system_metrics():
    """获取系统监控指标"""
    # 实现逻辑
    return {}
```

---

**文档完成时间**: 2025-01-21
**文档版本**: v1.0
**技术负责人**: AI Assistant
**审核状态**: 待审核

> 本设计文档严格遵循lev2mdapi开发指南.md中的技术规范，确保所有Level2接口调用的正确性和稳定性。所有算法实现均基于原始需求文档中的业务逻辑，支持参数动态调整以适应不同市场环境。
```
```
```
```
```
```
```
```